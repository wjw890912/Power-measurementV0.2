#line 1 "..\\i2c_gpio.c"
 









 
#line 1 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"
 
 
 




 
 



 












  


 








#line 45 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"


  
  typedef unsigned int size_t;










    



    typedef unsigned short wchar_t;  
#line 74 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"

typedef struct div_t { int quot, rem; } div_t;
    
typedef struct ldiv_t { long int quot, rem; } ldiv_t;
    

typedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
    


#line 95 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"
   



 

   




 
#line 114 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"
   


 
extern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);

   




 

   




 




extern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
   



 

extern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
   



 


extern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
   

















 

extern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
   

 

extern __declspec(__nothrow) long int strtol(const char * __restrict  ,
                        char ** __restrict  , int  ) __attribute__((__nonnull__(1)));
   



























 
extern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
                                       char ** __restrict  , int  ) __attribute__((__nonnull__(1)));
   


























 

 
extern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
                               char ** __restrict  , int  ) __attribute__((__nonnull__(1)));
   




 
extern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
                                         char ** __restrict  , int  ) __attribute__((__nonnull__(1)));
   



 

extern __declspec(__nothrow) int rand(void);
   







 
extern __declspec(__nothrow) void srand(unsigned int  );
   






 

struct _rand_state { int __x[57]; };
extern __declspec(__nothrow) int _rand_r(struct _rand_state *);
extern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
struct _ANSI_rand_state { int __x[1]; };
extern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
extern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
   


 

extern __declspec(__nothrow) void *calloc(size_t  , size_t  );
   



 
extern __declspec(__nothrow) void free(void *  );
   





 
extern __declspec(__nothrow) void *malloc(size_t  );
   



 
extern __declspec(__nothrow) void *realloc(void *  , size_t  );
   













 

extern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
   









 

typedef int (*__heapprt)(void *, char const *, ...);
extern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
                                           char const *  , ...),
                        void *  ) __attribute__((__nonnull__(1)));
   










 
extern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
                                           char const *  , ...),
                       void *  , int  ) __attribute__((__nonnull__(1)));
   














 
extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
   







 

extern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
   




 
#line 414 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"


extern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
   












 

extern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
   







      

extern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
   









 

extern __declspec(__nothrow) int  system(const char *  );
   









 

extern  void *bsearch(const void *  , const void *  ,
              size_t  , size_t  ,
              int (*  )(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
   












 
#line 502 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"


extern  void qsort(void *  , size_t  , size_t  ,
           int (*  )(const void *, const void *)) __attribute__((__nonnull__(1,4)));
   









 

#line 531 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"

extern __declspec(__nothrow) __pure int abs(int  );
   



 

extern __declspec(__nothrow) __pure div_t div(int  , int  );
   









 
extern __declspec(__nothrow) __pure long int labs(long int  );
   



 




extern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
   











 







extern __declspec(__nothrow) __pure __int64 llabs(__int64  );
   



 




extern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
   











 
#line 612 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"



 
typedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
typedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
    
typedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;

__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
     int  ,
     short int  );
   

 
__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
     unsigned int  ,
     unsigned short  );
   

 
__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
     int  , unsigned int  ,
     int  );
   

 



 
extern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
   







 























 
extern __declspec(__nothrow) int mblen(const char *  , size_t  );
   












 
extern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
                   const char * __restrict  , size_t  );
   















 
extern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
   













 





 
extern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
                      const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
   














 
extern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
                      const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
   














 

extern __declspec(__nothrow) void __use_realtime_heap(void);
extern __declspec(__nothrow) void __use_realtime_division(void);
extern __declspec(__nothrow) void __use_two_region_memory(void);
extern __declspec(__nothrow) void __use_no_heap(void);
extern __declspec(__nothrow) void __use_no_heap_region(void);

extern __declspec(__nothrow) char const *__C_library_version_string(void);
extern __declspec(__nothrow) int __C_library_version_number(void);











#line 866 "E:\\Keil\\ARM\\RV31\\INC\\stdlib.h"


 
#line 13 "..\\i2c_gpio.c"
#line 1 "..\\i2c_gpio.h"
 









 
#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
 









 






































 

















































 







 
 
 



 



 
typedef enum IRQn {
     
    NonMaskableInt_IRQn           = -14,       
    MemoryManagement_IRQn         = -12,       
    BusFault_IRQn                 = -11,       
    UsageFault_IRQn               = -10,       
    SVCall_IRQn                   = -5,        
    DebugMonitor_IRQn             = -4,        
    PendSV_IRQn                   = -2,        
    SysTick_IRQn                  = -1,        

     

    BOD_IRQn                      = 0,         
    IRC_IRQn                      = 1,         
    PWRWU_IRQn                    = 2,         
    SRAMF_IRQn                    = 3,         
    CLKF_IRQn                     = 4,         
    RTC_IRQn                      = 6,         
    TAMPER_IRQn                   = 7,         
    EINT0_IRQn                    = 8,         
    EINT1_IRQn                    = 9,         
    EINT2_IRQn                    = 10,        
    EINT3_IRQn                    = 11,        
    EINT4_IRQn                    = 12,        
    EINT5_IRQn                    = 13,        
    EINT6_IRQn                    = 14,        
    EINT7_IRQn                    = 15,        
    GPA_IRQn                      = 16,        
    GPB_IRQn                      = 17,        
    GPC_IRQn                      = 18,        
    GPD_IRQn                      = 19,        
    GPE_IRQn                      = 20,        
    GPF_IRQn                      = 21,        
    GPG_IRQn                      = 22,        
    GPH_IRQn                      = 23,        
    GPI_IRQn                      = 24,        
    TMR0_IRQn                     = 32,        
    TMR1_IRQn                     = 33,        
    TMR2_IRQn                     = 34,        
    TMR3_IRQn                     = 35,        
    PDMA_IRQn                     = 40,        
    ADC_IRQn                      = 42,        
    WDT_IRQn                      = 46,        
    WWDT_IRQn                     = 47,        
    EADC0_IRQn                    = 48,        
    EADC1_IRQn                    = 49,        
    EADC2_IRQn                    = 50,        
    EADC3_IRQn                    = 51,        
    ACMP_IRQn                     = 56,        
    OPA0_IRQn                     = 60,        
    OPA1_IRQn                     = 61,        
    ICAP0_IRQn                    = 62,        
    ICAP1_IRQn                    = 63,        
    PWM0CH0_IRQn                  = 64,        
    PWM0CH1_IRQn                  = 65,        
    PWM0CH2_IRQn                  = 66,        
    PWM0CH3_IRQn                  = 67,        
    PWM0CH4_IRQn                  = 68,        
    PWM0CH5_IRQn                  = 69,        
    PWM0_BRK_IRQn                 = 70,        
    QEI0_IRQn                     = 71,        
    PWM1CH0_IRQn                  = 72,        
    PWM1CH1_IRQn                  = 73,        
    PWM1CH2_IRQn                  = 74,        
    PWM1CH3_IRQn                  = 75,        
    PWM1CHCH4_IRQn                = 76,        
    PWM1CH5_IRQn                  = 77,        
    PWM1_BRK_IRQn                 = 78,        
    QEI1_IRQn                     = 79,        
    EPWM0_IRQn                    = 80,        
    EPWM0BRK_IRQn                 = 81,        
    EPWM1_IRQn                    = 82,        
    EPWM1BRK_IRQn                 = 83,        
    USBD_IRQn                     = 88,        
    USBH_IRQn                     = 89,        
    USB_OTG_IRQn                  = 90,        
    EMAC_TX_IRQn                  = 92,        
    EMAC_RX_IRQn                  = 93,        
    SPI0_IRQn                     = 96,        
    SPI1_IRQn                     = 97,        
    SPI2_IRQn                     = 98,        
    SPI3_IRQn                     = 99,        
    UART0_IRQn                    = 104,       
    UART1_IRQn                    = 105,       
    UART2_IRQn                    = 106,       
    UART3_IRQn                    = 107,       
    UART4_IRQn                    = 108,       
    UART5_IRQn                    = 109,       
    I2C0_IRQn                     = 112,       
    I2C1_IRQn                     = 113,       
    I2C2_IRQn                     = 114,       
    I2C3_IRQn                     = 115,       
    I2C4_IRQn                     = 116,       
    SC0_IRQn                      = 120,       
    SC1_IRQn                      = 121,       
    SC2_IRQn                      = 122,       
    SC3_IRQn                      = 123,       
    SC4_IRQn                      = 124,       
    SC5_IRQn                      = 125,       
    CAN0_IRQn                     = 128,       
    CAN1_IRQn                     = 129,       
    I2S0_IRQn                     = 132,       
    I2S1_IRQn                     = 133,       
    SD_IRQn                       = 136,       
    PS2D_IRQn                     = 138,       
    CAP_IRQn                      = 139,       
    CRPT_IRQn                     = 140,       
    CRC_IRQn                      = 141,       
}
IRQn_Type;






 

 






   


#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
 




















 






















 




 


 

 













#line 89 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"


 
#line 103 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 152 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"
 
 





 









#line 25 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"







 

     

     
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

     
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

     

     
     
typedef   signed          char int_least8_t;
typedef   signed short     int int_least16_t;
typedef   signed           int int_least32_t;
typedef   signed       __int64 int_least64_t;

     
typedef unsigned          char uint_least8_t;
typedef unsigned short     int uint_least16_t;
typedef unsigned           int uint_least32_t;
typedef unsigned       __int64 uint_least64_t;

     

     
typedef   signed           int int_fast8_t;
typedef   signed           int int_fast16_t;
typedef   signed           int int_fast32_t;
typedef   signed       __int64 int_fast64_t;

     
typedef unsigned           int uint_fast8_t;
typedef unsigned           int uint_fast16_t;
typedef unsigned           int uint_fast32_t;
typedef unsigned       __int64 uint_fast64_t;

     
typedef   signed           int intptr_t;
typedef unsigned           int uintptr_t;

     
typedef   signed       __int64 intmax_t;
typedef unsigned       __int64 uintmax_t;




     

     





     





     





     

     





     





     





     

     





     





     





     

     


     


     


     

     


     


     


     

     



     



     


     
    
 



#line 196 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"

     







     










     











#line 260 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"



 


#line 154 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
 




















 





 



 


 









 







 







 






 








 







 







 









 









 
__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
{
  rev16 r0, r0
  bx lr
}








 
__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
{
  revsh r0, r0
  bx lr
}









 











 









 









 









 











 











 











 







 










 










 









 






#line 615 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"

   

#line 155 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"
 




















 





 



 


 





 
 






 
static __inline uint32_t __get_CONTROL(void)
{
  register uint32_t __regControl         __asm("control");
  return(__regControl);
}







 
static __inline void __set_CONTROL(uint32_t control)
{
  register uint32_t __regControl         __asm("control");
  __regControl = control;
}







 
static __inline uint32_t __get_IPSR(void)
{
  register uint32_t __regIPSR          __asm("ipsr");
  return(__regIPSR);
}







 
static __inline uint32_t __get_APSR(void)
{
  register uint32_t __regAPSR          __asm("apsr");
  return(__regAPSR);
}







 
static __inline uint32_t __get_xPSR(void)
{
  register uint32_t __regXPSR          __asm("xpsr");
  return(__regXPSR);
}







 
static __inline uint32_t __get_PSP(void)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  return(__regProcessStackPointer);
}







 
static __inline void __set_PSP(uint32_t topOfProcStack)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  __regProcessStackPointer = topOfProcStack;
}







 
static __inline uint32_t __get_MSP(void)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  return(__regMainStackPointer);
}







 
static __inline void __set_MSP(uint32_t topOfMainStack)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  __regMainStackPointer = topOfMainStack;
}







 
static __inline uint32_t __get_PRIMASK(void)
{
  register uint32_t __regPriMask         __asm("primask");
  return(__regPriMask);
}







 
static __inline void __set_PRIMASK(uint32_t priMask)
{
  register uint32_t __regPriMask         __asm("primask");
  __regPriMask = (priMask);
}








 







 








 
static __inline uint32_t  __get_BASEPRI(void)
{
  register uint32_t __regBasePri         __asm("basepri");
  return(__regBasePri);
}







 
static __inline void __set_BASEPRI(uint32_t basePri)
{
  register uint32_t __regBasePri         __asm("basepri");
  __regBasePri = (basePri & 0xff);
}







 
static __inline uint32_t __get_FAULTMASK(void)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  return(__regFaultMask);
}







 
static __inline void __set_FAULTMASK(uint32_t faultMask)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  __regFaultMask = (faultMask & (uint32_t)1);
}











 
static __inline uint32_t __get_FPSCR(void)
{

  register uint32_t __regfpscr         __asm("fpscr");
  return(__regfpscr);



}







 
static __inline void __set_FPSCR(uint32_t fpscr)
{

  register uint32_t __regfpscr         __asm("fpscr");
  __regfpscr = (fpscr);

}




#line 612 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"

 


#line 156 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"
 




















 











 


 



 


 

 
#line 106 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"








 



#line 641 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"

 




#line 157 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"








 
#line 192 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 






 
#line 208 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 













 


 





 


 
typedef union
{
  struct
  {



    uint32_t _reserved0:16;               
    uint32_t GE:4;                        
    uint32_t _reserved1:7;                

    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} APSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       
    uint32_t _reserved0:23;               
  } b;                                    
  uint32_t w;                             
} IPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       



    uint32_t _reserved0:7;                
    uint32_t GE:4;                        
    uint32_t _reserved1:4;                

    uint32_t T:1;                         
    uint32_t IT:2;                        
    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} xPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t nPRIV:1;                     
    uint32_t SPSEL:1;                     
    uint32_t FPCA:1;                      
    uint32_t _reserved0:29;               
  } b;                                    
  uint32_t w;                             
} CONTROL_Type;

 






 


 
typedef struct
{
  volatile uint32_t ISER[8];                  
       uint32_t RESERVED0[24];
  volatile uint32_t ICER[8];                  
       uint32_t RSERVED1[24];
  volatile uint32_t ISPR[8];                  
       uint32_t RESERVED2[24];
  volatile uint32_t ICPR[8];                  
       uint32_t RESERVED3[24];
  volatile uint32_t IABR[8];                  
       uint32_t RESERVED4[56];
  volatile uint8_t  IP[240];                  
       uint32_t RESERVED5[644];
  volatile  uint32_t STIR;                     
}  NVIC_Type;

 



 






 


 
typedef struct
{
  volatile const  uint32_t CPUID;                    
  volatile uint32_t ICSR;                     
  volatile uint32_t VTOR;                     
  volatile uint32_t AIRCR;                    
  volatile uint32_t SCR;                      
  volatile uint32_t CCR;                      
  volatile uint8_t  SHP[12];                  
  volatile uint32_t SHCSR;                    
  volatile uint32_t CFSR;                     
  volatile uint32_t HFSR;                     
  volatile uint32_t DFSR;                     
  volatile uint32_t MMFAR;                    
  volatile uint32_t BFAR;                     
  volatile uint32_t AFSR;                     
  volatile const  uint32_t PFR[2];                   
  volatile const  uint32_t DFR;                      
  volatile const  uint32_t ADR;                      
  volatile const  uint32_t MMFR[4];                  
  volatile const  uint32_t ISAR[5];                  
       uint32_t RESERVED0[5];
  volatile uint32_t CPACR;                    
} SCB_Type;

 















 






























 



 





















 









 


















 










































 









 









 















 






 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile const  uint32_t ICTR;                     
  volatile uint32_t ACTLR;                    
} SCnSCB_Type;

 



 















 






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t LOAD;                     
  volatile uint32_t VAL;                      
  volatile const  uint32_t CALIB;                    
} SysTick_Type;

 












 



 



 









 






 


 
typedef struct
{
  volatile  union
  {
    volatile  uint8_t    u8;                   
    volatile  uint16_t   u16;                  
    volatile  uint32_t   u32;                  
  }  PORT [32];                           
       uint32_t RESERVED0[864];
  volatile uint32_t TER;                      
       uint32_t RESERVED1[15];
  volatile uint32_t TPR;                      
       uint32_t RESERVED2[15];
  volatile uint32_t TCR;                      
       uint32_t RESERVED3[29];                                  
  volatile  uint32_t IWR;                      
  volatile const  uint32_t IRR;                      
  volatile uint32_t IMCR;                     
       uint32_t RESERVED4[43];                                  
  volatile  uint32_t LAR;                      
  volatile const  uint32_t LSR;                      
       uint32_t RESERVED5[6];                                   
  volatile const  uint32_t PID4;                     
  volatile const  uint32_t PID5;                     
  volatile const  uint32_t PID6;                     
  volatile const  uint32_t PID7;                     
  volatile const  uint32_t PID0;                     
  volatile const  uint32_t PID1;                     
  volatile const  uint32_t PID2;                     
  volatile const  uint32_t PID3;                     
  volatile const  uint32_t CID0;                     
  volatile const  uint32_t CID1;                     
  volatile const  uint32_t CID2;                     
  volatile const  uint32_t CID3;                     
} ITM_Type;

 



 



























 



 



 



 









   






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t CYCCNT;                   
  volatile uint32_t CPICNT;                   
  volatile uint32_t EXCCNT;                   
  volatile uint32_t SLEEPCNT;                 
  volatile uint32_t LSUCNT;                   
  volatile uint32_t FOLDCNT;                  
  volatile const  uint32_t PCSR;                     
  volatile uint32_t COMP0;                    
  volatile uint32_t MASK0;                    
  volatile uint32_t FUNCTION0;                
       uint32_t RESERVED0[1];
  volatile uint32_t COMP1;                    
  volatile uint32_t MASK1;                    
  volatile uint32_t FUNCTION1;                
       uint32_t RESERVED1[1];
  volatile uint32_t COMP2;                    
  volatile uint32_t MASK2;                    
  volatile uint32_t FUNCTION2;                
       uint32_t RESERVED2[1];
  volatile uint32_t COMP3;                    
  volatile uint32_t MASK3;                    
  volatile uint32_t FUNCTION3;                
} DWT_Type;

 






















































 



 



 



 



 



 



 



























   






 


 
typedef struct
{
  volatile uint32_t SSPSR;                    
  volatile uint32_t CSPSR;                    
       uint32_t RESERVED0[2];
  volatile uint32_t ACPR;                     
       uint32_t RESERVED1[55];
  volatile uint32_t SPPR;                     
       uint32_t RESERVED2[131];
  volatile const  uint32_t FFSR;                     
  volatile uint32_t FFCR;                     
  volatile const  uint32_t FSCR;                     
       uint32_t RESERVED3[759];
  volatile const  uint32_t TRIGGER;                  
  volatile const  uint32_t FIFO0;                    
  volatile const  uint32_t ITATBCTR2;                
       uint32_t RESERVED4[1];
  volatile const  uint32_t ITATBCTR0;                
  volatile const  uint32_t FIFO1;                    
  volatile uint32_t ITCTRL;                   
       uint32_t RESERVED5[39];
  volatile uint32_t CLAIMSET;                 
  volatile uint32_t CLAIMCLR;                 
       uint32_t RESERVED7[8];
  volatile const  uint32_t DEVID;                    
  volatile const  uint32_t DEVTYPE;                  
} TPI_Type;

 



 



 












 






 



 





















 



 





















 



 



 


















 






   







 


 
typedef struct
{
  volatile const  uint32_t TYPE;                     
  volatile uint32_t CTRL;                     
  volatile uint32_t RNR;                      
  volatile uint32_t RBAR;                     
  volatile uint32_t RASR;                     
  volatile uint32_t RBAR_A1;                  
  volatile uint32_t RASR_A1;                  
  volatile uint32_t RBAR_A2;                  
  volatile uint32_t RASR_A2;                  
  volatile uint32_t RBAR_A3;                  
  volatile uint32_t RASR_A3;                  
} MPU_Type;

 









 









 



 









 






























 








 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile uint32_t FPCCR;                    
  volatile uint32_t FPCAR;                    
  volatile uint32_t FPDSCR;                   
  volatile const  uint32_t MVFR0;                    
  volatile const  uint32_t MVFR1;                    
} FPU_Type;

 



























 



 












 
























 












 







 


 
typedef struct
{
  volatile uint32_t DHCSR;                    
  volatile  uint32_t DCRSR;                    
  volatile uint32_t DCRDR;                    
  volatile uint32_t DEMCR;                    
} CoreDebug_Type;

 




































 






 







































 






 

 
#line 1366 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1375 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"











 










 

 



 




 










 
static __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);                

  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << 16) |
                (PriorityGroupTmp << 8));                                      
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
}







 
static __inline uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
}







 
static __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
}







 
static __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}











 
static __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}







 
static __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}







 
static __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}










 
static __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}










 
static __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
  else {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
}












 
static __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if(IRQn < 0) {
    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
  else {
    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
}













 
static __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}













 
static __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
}





 
static __inline void NVIC_SystemReset(void)
{
  __dsb(0xF);                                                     
 
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
                 (1UL << 2));                    
  __dsb(0xF);                                                      
  while(1);                                                     
}

 



 




 

















 
static __inline uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > (0xFFFFFFUL << 0))  return (1);             

  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
                   (1UL << 1)   |
                   (1UL << 0);                     
  return (0);                                                   
}



 



 




 

extern volatile int32_t ITM_RxBuffer;                     












 
static __inline uint32_t ITM_SendChar (uint32_t ch)
{
  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
  {
    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
  }
  return (ch);
}








 
static __inline int32_t ITM_ReceiveChar (void) {
  int32_t ch = -1;                            

  if (ITM_RxBuffer != 0x5AA55AA5) {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = 0x5AA55AA5;        
  }

  return (ch);
}








 
static __inline int32_t ITM_CheckChar (void) {

  if (ITM_RxBuffer == 0x5AA55AA5) {
    return (0);                                  
  } else {
    return (1);                                  
  }
}

 





#line 249 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\system_NUC472_442.h"
 








 







#line 19 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\system_NUC472_442.h"




 







extern uint32_t SystemCoreClock;      
extern uint32_t CyclesPerUs;          
extern uint32_t PllClock;             








 
extern void SystemInit (void);








 
extern void SystemCoreClockUpdate (void);






 
#line 250 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 251 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
 
 



 


#pragma anon_unions



 



 

typedef struct {


    





























 
    volatile uint32_t CTL[3];

    



























 
    volatile uint32_t STATUS;

    














 
    volatile uint32_t VREF;

} ACMP_T;




 














































   
   


 



 

typedef struct {


    



















 
    volatile const  uint32_t DAT[14];


    uint32_t RESERVE0[2];


    



































































 
    volatile uint32_t CTL;

    



















 
    volatile uint32_t CHEN;

    










































 
    volatile uint32_t CMP[2];

    





























 
    volatile uint32_t STATUS0;

    










 
    volatile const  uint32_t STATUS1;
    uint32_t RESERVE1[2];


    








 
    volatile const  uint32_t CURDAT;

} ADC_T;




 





































































































































































































































   
   


 



 

typedef struct {

    















 
    volatile uint32_t CREQ;

    



























































 
    volatile uint32_t CMASK;

    









 
    volatile uint32_t MASK1;

    

















 
    volatile uint32_t MASK2;

    









 
    volatile uint32_t ARB1;

    
























 
    volatile uint32_t ARB2;

    





















































 
    volatile uint32_t MCON;

    










 
    volatile uint32_t DAT_A1;

    










 
    volatile uint32_t DAT_A2;

    










 
    volatile uint32_t DAT_B1;

    










 
    volatile uint32_t DAT_B2;

    volatile const uint32_t RESERVE0[13];

} CAN_IF_T;

typedef struct {

    



























 
    volatile uint32_t   CON;

    




























 
    volatile uint32_t   STATUS;

    













 
    volatile uint32_t   ERR;

    




















 
    volatile uint32_t   BTIME;

    















 
    volatile uint32_t   IIDR;

    


























 
    volatile uint32_t   TEST;

    









 
    volatile uint32_t   BRPE;

    volatile const uint32_t    RESERVE0[1];

    volatile CAN_IF_T   IF[2];

    volatile const uint32_t    RESERVE1[8];

    










 
    volatile uint32_t   TXREQ1;

    










 
    volatile uint32_t   TXREQ2;

    volatile const uint32_t    RESERVE2[6];

    









 
    volatile uint32_t   NDAT1;

    









 
    volatile uint32_t   NDAT2;

    volatile const uint32_t    RESERVE3[6];

    









 
    volatile uint32_t   IPND1;

    









 
    volatile uint32_t   IPND2;

    volatile const uint32_t    RESERVE4[6];

    












 
    volatile uint32_t   MVLD1;

    











 
    volatile uint32_t   MVLD2;

    










 
    volatile uint32_t WU_EN;

    










 
    volatile uint32_t WU_STATUS;
} CAN_T;




 































































































































































































































   
   


 



 

typedef struct {


    



























 
    volatile uint32_t CTL;

    





































































 
    volatile uint32_t PAR;

    





























 
    volatile uint32_t INT;

    












 
    volatile uint32_t POSTERIZE;

    





















 
    volatile uint32_t MD;

    







 
    volatile uint32_t MDADDR;

    







 
    volatile uint32_t MDYADDR;

    








 
    volatile uint32_t SEPIA;

    








 
    volatile uint32_t CWSP;

    








 
    volatile uint32_t CWS;

    






















 
    volatile uint32_t PKTSL;

    






















 
    volatile uint32_t PLNSL;

    












 
    volatile uint32_t FRCTL;

    










 
    volatile uint32_t STRIDE;
    uint32_t RESERVE0[1];


    











 
    volatile uint32_t FIFOTH;

    








 
    volatile uint32_t CMPADDR;
    uint32_t RESERVE1[1];


    


















 
    volatile uint32_t PKTSM;

    


















 
    volatile uint32_t PLNSM;

    







 
    volatile const  uint32_t CURADDRP;

    







 
    volatile const  uint32_t CURADDRY;

    







 
    volatile const  uint32_t CURADDRU;

    







 
    volatile const  uint32_t CURVADDR;

    








 
    volatile uint32_t PKTBA0;

    








 
    volatile uint32_t PKTBA1;
    uint32_t RESERVE2[6];


    








 
    volatile uint32_t YBA;

    








 
    volatile uint32_t UBA;

    








 
    volatile uint32_t VBA;

} CAP_T;




 








































































































































































































































   
   


 



 

typedef struct {


    









 
    volatile uint32_t CNT;

    









 
    volatile uint32_t HOLD0;

    









 
    volatile uint32_t HOLD1;

    









 
    volatile uint32_t HOLD2;

    









 
    volatile uint32_t CNTCMP;

    

















































































 
    volatile uint32_t CTL0;

    













































 
    volatile uint32_t CTL1;

    































 
    volatile uint32_t STATUS;

} ECAP_T;




 










































































































   
   


 



 

typedef struct {


    























































 
    volatile uint32_t PWRCTL;

    







































 
    volatile uint32_t AHBCLK;

    
































































































 
    volatile uint32_t APBCLK0;

    





































































 
    volatile uint32_t APBCLK1;

    



























































 
    volatile uint32_t CLKSEL0;

    












































































 
    volatile uint32_t CLKSEL1;

    




























































 
    volatile uint32_t CLKSEL2;

    














































 
    volatile uint32_t CLKSEL3;

    
















 
    volatile uint32_t CLKDIV0;

    














 
    volatile uint32_t CLKDIV1;

    










 
    volatile uint32_t CLKDIV2;

    












 
    volatile uint32_t CLKDIV3;
    uint32_t RESERVE0[4];


    




























 
    volatile uint32_t PLLCTL;

    













 
    volatile uint32_t PLL2CTL;
    uint32_t RESERVE1[2];


    





































 
    volatile uint32_t STATUS;
    uint32_t RESERVE2[3];


    


















 
    volatile uint32_t CLKOCTL;
    uint32_t RESERVE3[3];


    
























 
    volatile uint32_t CLKDCTL;

} CLK_T;




 

















































































































































































































































































































































































































































   
   


 



 

typedef struct {


    








































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t DAT;

    








 
    volatile uint32_t SEED;

    








 
    volatile const  uint32_t CHECKSUM;

} CRC_T;




 


































   
   


 



 

typedef struct {
    

































 
    volatile uint32_t INTEN;

    






































 
    volatile uint32_t INTSTS;

    




















 
    volatile uint32_t PRNG_CTL;

    








 
    volatile  uint32_t PRNG_SEED;

    








 
    volatile const  uint32_t PRNG_KEY0;

    








 
    volatile const  uint32_t PRNG_KEY1;

    








 
    volatile const  uint32_t PRNG_KEY2;

    








 
    volatile const  uint32_t PRNG_KEY3;

    








 
    volatile const  uint32_t PRNG_KEY4;

    








 
    volatile const  uint32_t PRNG_KEY5;

    








 
    volatile const  uint32_t PRNG_KEY6;

    








 
    volatile const  uint32_t PRNG_KEY7;
    uint32_t RESERVE0[8];


    













 
    volatile const  uint32_t AES_FDBCK0;

    













 
    volatile const  uint32_t AES_FDBCK1;

    













 
    volatile const  uint32_t AES_FDBCK2;

    













 
    volatile const  uint32_t AES_FDBCK3;

    















 
    volatile const  uint32_t TDES_FDBCKH;

    















 
    volatile const  uint32_t TDES_FDBCKL;
    uint32_t RESERVE1[38];


    



































































 
    volatile uint32_t AES_CTL;

    








































 
    volatile const  uint32_t AES_STS;

    








 
    volatile uint32_t AES_DATIN;

    









 
    volatile const  uint32_t AES_DATOUT;

    














 
    volatile uint32_t AES0_KEY0;

    














 
    volatile uint32_t AES0_KEY1;

    














 
    volatile uint32_t AES0_KEY2;

    














 
    volatile uint32_t AES0_KEY3;

    














 
    volatile uint32_t AES0_KEY4;

    














 
    volatile uint32_t AES0_KEY5;

    














 
    volatile uint32_t AES0_KEY6;

    














 
    volatile uint32_t AES0_KEY7;

    











 
    volatile uint32_t AES0_IV0;

    











 
    volatile uint32_t AES0_IV1;

    











 
    volatile uint32_t AES0_IV2;

    











 
    volatile uint32_t AES0_IV3;

    


















 
    volatile uint32_t AES0_SADDR;

    


















 
    volatile uint32_t AES0_DADDR;

    

















 
    volatile uint32_t AES0_CNT;

    














 
    volatile uint32_t AES1_KEY0;

    














 
    volatile uint32_t AES1_KEY1;

    














 
    volatile uint32_t AES1_KEY2;

    














 
    volatile uint32_t AES1_KEY3;

    














 
    volatile uint32_t AES1_KEY4;

    














 
    volatile uint32_t AES1_KEY5;

    














 
    volatile uint32_t AES1_KEY6;

    














 
    volatile uint32_t AES1_KEY7;

    











 
    volatile uint32_t AES1_IV0;

    











 
    volatile uint32_t AES1_IV1;

    











 
    volatile uint32_t AES1_IV2;

    











 
    volatile uint32_t AES1_IV3;

    


















 
    volatile uint32_t AES1_SADDR;

    


















 
    volatile uint32_t AES1_DADDR;

    

















 
    volatile uint32_t AES1_CNT;

    














 
    volatile uint32_t AES2_KEY0;

    














 
    volatile uint32_t AES2_KEY1;

    














 
    volatile uint32_t AES2_KEY2;

    














 
    volatile uint32_t AES2_KEY3;

    














 
    volatile uint32_t AES2_KEY4;

    














 
    volatile uint32_t AES2_KEY5;

    














 
    volatile uint32_t AES2_KEY6;

    














 
    volatile uint32_t AES2_KEY7;

    











 
    volatile uint32_t AES2_IV0;

    











 
    volatile uint32_t AES2_IV1;

    











 
    volatile uint32_t AES2_IV2;

    











 
    volatile uint32_t AES2_IV3;

    


















 
    volatile uint32_t AES2_SADDR;

    


















 
    volatile uint32_t AES2_DADDR;

    

















 
    volatile uint32_t AES2_CNT;

    














 
    volatile uint32_t AES3_KEY0;

    














 
    volatile uint32_t AES3_KEY1;

    














 
    volatile uint32_t AES3_KEY2;

    














 
    volatile uint32_t AES3_KEY3;

    














 
    volatile uint32_t AES3_KEY4;

    














 
    volatile uint32_t AES3_KEY5;

    














 
    volatile uint32_t AES3_KEY6;

    














 
    volatile uint32_t AES3_KEY7;

    











 
    volatile uint32_t AES3_IV0;

    











 
    volatile uint32_t AES3_IV1;

    











 
    volatile uint32_t AES3_IV2;

    











 
    volatile uint32_t AES3_IV3;

    


















 
    volatile uint32_t AES3_SADDR;

    


















 
    volatile uint32_t AES3_DADDR;

    

















 
    volatile uint32_t AES3_CNT;

    


































































 
    volatile uint32_t TDES_CTL;

    




































 
    volatile const  uint32_t TDES_STS;

    











 
    volatile uint32_t TDES0_KEY1H;

    











 
    volatile uint32_t TDES0_KEY1L;

    











 
    volatile uint32_t TDES0_KEY2H;

    











 
    volatile uint32_t TDES0_KEY2L;

    











 
    volatile uint32_t TDES0_KEY3H;

    











 
    volatile uint32_t TDES0_KEY3L;

    









 
    volatile uint32_t TDES0_IVH;

    









 
    volatile uint32_t TDES0_IVL;

    


















 
    volatile uint32_t TDES0_SADDR;

    


















 
    volatile uint32_t TDES0_DADDR;

    














 
    volatile uint32_t TDES0_CNT;

    









 
    volatile uint32_t TDES_DATIN;

    









 
    volatile const  uint32_t TDES_DATOUT;
    uint32_t RESERVE2[3];


    











 
    volatile uint32_t TDES1_KEY1H;

    











 
    volatile uint32_t TDES1_KEY1L;

    











 
    volatile uint32_t TDES1_KEY2H;

    











 
    volatile uint32_t TDES1_KEY2L;

    











 
    volatile uint32_t TDES1_KEY3H;

    











 
    volatile uint32_t TDES1_KEY3L;

    









 
    volatile uint32_t TDES1_IVH;

    









 
    volatile uint32_t TDES1_IVL;

    


















 
    volatile uint32_t TDES1_SADDR;

    


















 
    volatile uint32_t TDES1_DADDR;

    














 
    volatile uint32_t TDES1_CNT;
    uint32_t RESERVE3[5];


    











 
    volatile uint32_t TDES2_KEY1H;

    











 
    volatile uint32_t TDES2_KEY1L;

    











 
    volatile uint32_t TDES2_KEY2H;

    











 
    volatile uint32_t TDES2_KEY2L;

    











 
    volatile uint32_t TDES2_KEY3H;

    











 
    volatile uint32_t TDES2_KEY3L;

    









 
    volatile uint32_t TDES2_IVH;

    









 
    volatile uint32_t TDES2_IVL;

    


















 
    volatile uint32_t TDES2_SADDR;

    


















 
    volatile uint32_t TDES2_DADDR;

    














 
    volatile uint32_t TDES2_CNT;
    uint32_t RESERVE4[5];


    











 
    volatile uint32_t TDES3_KEY1H;

    











 
    volatile uint32_t TDES3_KEY1L;

    











 
    volatile uint32_t TDES3_KEY2H;

    











 
    volatile uint32_t TDES3_KEY2L;

    











 
    volatile uint32_t TDES3_KEY3H;

    











 
    volatile uint32_t TDES3_KEY3L;

    









 
    volatile uint32_t TDES3_IVH;

    









 
    volatile uint32_t TDES3_IVL;

    


















 
    volatile uint32_t TDES3_SADDR;

    


















 
    volatile uint32_t TDES3_DADDR;

    














 
    volatile uint32_t TDES3_CNT;
    uint32_t RESERVE5[3];


    

































 
    volatile uint32_t SHA_CTL;

    


















 
    volatile const  uint32_t SHA_STS;

    










 
    volatile const  uint32_t SHA_DGST0;

    










 
    volatile const  uint32_t SHA_DGST1;

    










 
    volatile const  uint32_t SHA_DGST2;

    










 
    volatile const  uint32_t SHA_DGST3;

    










 
    volatile const  uint32_t SHA_DGST4;

    










 
    volatile const  uint32_t SHA_DGST5;

    










 
    volatile const  uint32_t SHA_DGST6;

    










 
    volatile const  uint32_t SHA_DGST7;
    uint32_t RESERVE6[8];


    













 
    volatile uint32_t SHA_KEYCNT;

    


















 
    volatile uint32_t SHA_SADDR;

    














 
    volatile uint32_t SHA_DMACNT;

    








 
    volatile uint32_t SHA_DATIN;

} CRPT_T;




 




















































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    

















 
    volatile const  uint32_t AD0DAT0;

    

















 
    volatile const  uint32_t AD0DAT1;

    

















 
    volatile const  uint32_t AD0DAT2;

    

















 
    volatile const  uint32_t AD0DAT3;

    

















 
    volatile const  uint32_t AD0DAT4;

    

















 
    volatile const  uint32_t AD0DAT5;

    

















 
    volatile const  uint32_t AD0DAT6;

    

















 
    volatile const  uint32_t AD0DAT7;

    

















 
    volatile const  uint32_t AD1DAT0;

    

















 
    volatile const  uint32_t AD1DAT1;

    

















 
    volatile const  uint32_t AD1DAT2;

    

















 
    volatile const  uint32_t AD1DAT3;

    

















 
    volatile const  uint32_t AD1DAT4;

    

















 
    volatile const  uint32_t AD1DAT5;

    

















 
    volatile const  uint32_t AD1DAT6;

    

















 
    volatile const  uint32_t AD1DAT7;

    



































 
    volatile uint32_t CTL;
    uint32_t RESERVE0[1];


    














 
    volatile  uint32_t SWTRG;

    
















 
    volatile const  uint32_t PENDSTS;

    






















 
    volatile uint32_t ADIFOV;

    


















 
    volatile uint32_t OVSTS;

    





















































 
    volatile uint32_t AD0SPCTL0;

    





















































 
    volatile uint32_t AD0SPCTL1;

    





















































 
    volatile uint32_t AD0SPCTL2;

    





















































 
    volatile uint32_t AD0SPCTL3;

    





































 
    volatile uint32_t AD0SPCTL4;

    





































 
    volatile uint32_t AD0SPCTL5;

    





































 
    volatile uint32_t AD0SPCTL6;

    





































 
    volatile uint32_t AD0SPCTL7;

    





















































 
    volatile uint32_t AD1SPCTL0;

    





















































 
    volatile uint32_t AD1SPCTL1;

    





















































 
    volatile uint32_t AD1SPCTL2;

    





















































 
    volatile uint32_t AD1SPCTL3;

    





































 
    volatile uint32_t AD1SPCTL4;

    





































 
    volatile uint32_t AD1SPCTL5;

    





































 
    volatile uint32_t AD1SPCTL6;

    





































 
    volatile uint32_t AD1SPCTL7;
    uint32_t RESERVE1[3];


    






































 
    volatile uint32_t SIMUSEL;

    

































 
    volatile uint32_t CMP0;

    

































 
    volatile uint32_t CMP1;

    


















 
    volatile const  uint32_t STATUS0;

    

































































































 
    volatile uint32_t STATUS1;

    












 
    volatile uint32_t EXTSMPT;
    uint32_t RESERVE2[17];


    












 
    volatile const  uint32_t AD0DDAT0;

    












 
    volatile const  uint32_t AD0DDAT1;

    












 
    volatile const  uint32_t AD0DDAT2;

    












 
    volatile const  uint32_t AD0DDAT3;
    uint32_t RESERVE3[4];


    












 
    volatile const  uint32_t AD1DDAT0;

    












 
    volatile const  uint32_t AD1DDAT1;

    












 
    volatile const  uint32_t AD1DDAT2;

    












 
    volatile const  uint32_t AD1DDAT3;

    






























 
    volatile uint32_t DBMEN;

    






















































 
    volatile uint32_t INTSRC0;

    






















































 
    volatile uint32_t INTSRC1;

    






















































 
    volatile uint32_t INTSRC2;

    






















































 
    volatile uint32_t INTSRC3;

    






































































































 
    volatile uint32_t AD0TRGEN0;

    






































































































 
    volatile uint32_t AD0TRGEN1;

    






































































































 
    volatile uint32_t AD0TRGEN2;

    






































































































 
    volatile uint32_t AD0TRGEN3;

    






































































































 
    volatile uint32_t AD1TRGEN0;

    






































































































 
    volatile uint32_t AD1TRGEN1;

    






































































































 
    volatile uint32_t AD1TRGEN2;

    






































































































 
    volatile uint32_t AD1TRGEN3;

} EADC_T;




 























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    
























 
    volatile uint32_t CTL;

    






































 
    volatile uint32_t TCTL[3];

    







 
    volatile uint32_t KEY0;

    







 
    volatile uint32_t KEY1;

    







 
    volatile uint32_t KEY2;

    







 
    volatile uint32_t KEY3;

} EBI_T;




 

















































   
   


 



 

typedef struct {


    
































 
    volatile uint32_t CAMCTL;

    












 
    volatile uint32_t CAMEN;

    














 
    volatile uint32_t CAM0M;

    













 
    volatile uint32_t CAM0L;

    














 
    volatile uint32_t CAM1M;

    













 
    volatile uint32_t CAM1L;

    














 
    volatile uint32_t CAM2M;

    













 
    volatile uint32_t CAM2L;

    














 
    volatile uint32_t CAM3M;

    













 
    volatile uint32_t CAM3L;

    














 
    volatile uint32_t CAM4M;

    













 
    volatile uint32_t CAM4L;

    














 
    volatile uint32_t CAM5M;

    













 
    volatile uint32_t CAM5L;

    














 
    volatile uint32_t CAM6M;

    













 
    volatile uint32_t CAM6L;

    














 
    volatile uint32_t CAM7M;

    













 
    volatile uint32_t CAM7L;

    














 
    volatile uint32_t CAM8M;

    













 
    volatile uint32_t CAM8L;

    














 
    volatile uint32_t CAM9M;

    













 
    volatile uint32_t CAM9L;

    














 
    volatile uint32_t CAM10M;

    













 
    volatile uint32_t CAM10L;

    














 
    volatile uint32_t CAM11M;

    













 
    volatile uint32_t CAM11L;

    














 
    volatile uint32_t CAM12M;

    













 
    volatile uint32_t CAM12L;

    














 
    volatile uint32_t CAM13M;

    













 
    volatile uint32_t CAM13L;

    














 
    volatile uint32_t CAM14M;

    













 
    volatile uint32_t CAM14L;

    










 
    volatile uint32_t CAM15MSB;

    









 
    volatile uint32_t CAM15LSB;

    












 
    volatile uint32_t TXDSA;

    












 
    volatile uint32_t RXDSA;

    








































































































 
    volatile uint32_t CTL;

    








 
    volatile uint32_t MIIMDAT;

    
































 
    volatile uint32_t MIIMCTL;

    



































 
    volatile uint32_t FIFOCTL;

    











 
    volatile  uint32_t TXST;

    











 
    volatile  uint32_t RXST;

    










 
    volatile uint32_t MRFL;

    


























































































































































 
    volatile uint32_t INTEN;

    














































































































































































 
    volatile uint32_t INTSTS;

    














































 
    volatile uint32_t GENSTS;

    












 
    volatile uint32_t MPCNT;

    









 
    volatile const  uint32_t RPCNT;
    uint32_t RESERVE0[2];


    










 
    volatile uint32_t FRSTS;

    









 
    volatile const  uint32_t CTXDSA;

    









 
    volatile const  uint32_t CTXBSA;

    









 
    volatile const  uint32_t CRXDSA;

    









 
    volatile const  uint32_t CRXBSA;
    uint32_t RESERVE1[9];


    





























 
    volatile uint32_t TSCTL;
    uint32_t RESERVE2[3];


    









 
    volatile const  uint32_t TSSEC;

    









 
    volatile const  uint32_t TSSUBSEC;

    









 
    volatile uint32_t TSINC;

    










 
    volatile uint32_t TSADDEND;

    










 
    volatile uint32_t UPDSEC;

    










 
    volatile uint32_t UPDSUBSEC;

    










 
    volatile uint32_t ALMSEC;

    










 
    volatile uint32_t ALMSUBSEC;

} EMAC_T;




 



























































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    



































































































 
    volatile uint32_t CTL;

    














































 
    volatile uint32_t STATUS;

    













 
    volatile uint32_t PERIOD;

    













 
    volatile uint32_t CMPDAT0;

    













 
    volatile uint32_t CMPDAT2;

    













 
    volatile uint32_t CMPDAT4;

    












 
    volatile uint32_t MSKEN;

    











 
    volatile uint32_t MSK;

    








 
    volatile uint32_t ASYMCMP0;

    








 
    volatile uint32_t ASYMCMP2;

    








 
    volatile uint32_t ASYMCMP4;

    



























 
    volatile uint32_t DTCTL;

    











 
    volatile uint32_t BRKOUT;

    











 
    volatile uint32_t NPCTL;

    












































































 
    volatile uint32_t ASYMCTL;

    









 
    volatile uint32_t PERIODCNT;

    
























 
    volatile uint32_t EINTCTL;

    












 
    volatile uint32_t OUTEN0;

} EPWM_T;




 



























































































































































































   
   


 



 

typedef struct {
    



































 
    volatile uint32_t ISPCTL;

    









 
    volatile uint32_t ISPADDR;

    









 
    volatile uint32_t ISPDAT;

    








 
    volatile uint32_t ISPCMD;

    












 
    volatile uint32_t ISPTRG;

    









 
    volatile const  uint32_t DFBA;

    


















 
    volatile uint32_t FTCTL;
    uint32_t RESERVE0[9];

    


























 
    volatile uint32_t ISPSTS;

    
















































































 
    volatile uint32_t FBWP;
    uint32_t RESERVE1[14];

    









 
    volatile uint32_t MPDAT0;

    








 
    volatile uint32_t MPDAT1;

    








 
    volatile uint32_t MPDAT2;

    








 
    volatile uint32_t MPDAT3;

    uint32_t RESERVE2[12];

    































 
    volatile uint32_t MPSTS;

    










 
    volatile uint32_t MPADDR;

} FMC_T;





 
























































































   
   


 



 

typedef struct {


    






















































































































































 
    volatile uint32_t MODE;

    






















































































 
    volatile uint32_t DINOFF;

    






































































 
    volatile uint32_t DOUT;

    






































































































 
    volatile uint32_t DATMSK;

    






















































 
    volatile const  uint32_t PIN;

    






















































































































 
    volatile uint32_t DBEN;

    






















































































































































































 
    volatile uint32_t INTTYPE;

    






































































































































































 
    volatile uint32_t INTEN;

    






















































































































 
    volatile uint32_t INTSRC;

    






































 
    volatile uint32_t SMTEN;

    






































 
    volatile uint32_t SLEWCTL;

} GPIO_T;


typedef struct {

    






























 
    volatile uint32_t DBCTL;

} GPIO_DB_T;




 










































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    




























 
    volatile uint32_t CTL;

    













 
    volatile uint32_t ADDR0;

    








 
    volatile uint32_t DAT;

    











 
    volatile const  uint32_t STATUS;

    









 
    volatile uint32_t CLKDIV;

    


















 
    volatile uint32_t TOCTL;

    













 
    volatile uint32_t ADDR1;

    













 
    volatile uint32_t ADDR2;

    













 
    volatile uint32_t ADDR3;

    












 
    volatile uint32_t ADDRMSK0;

    












 
    volatile uint32_t ADDRMSK1;

    












 
    volatile uint32_t ADDRMSK2;

    












 
    volatile uint32_t ADDRMSK3;
    uint32_t RESERVE0[2];


    









 
    volatile uint32_t WKCTL;

    










 
    volatile uint32_t WKSTS;

} I2C_T;




 















































































   
   


 



 

typedef struct {


    




































































































 
    volatile uint32_t CTL;

    


















 
    volatile uint32_t CLKDIV;

    







































 
    volatile uint32_t IEN;

    






























































































 
    volatile const  uint32_t STATUS;

    










 
    volatile  uint32_t TX;

    










 
    volatile const  uint32_t RX;

} I2S_T;




 























































































































































   
   


 



 

typedef struct {


    






























 
    volatile uint32_t CTL;

    


















 
    volatile uint32_t STATUS;

} OPA_T;




 































   
   


 



 

typedef struct {


    



























 
    volatile uint32_t CTL;

    






































 
    volatile uint32_t PHYCTL;

    















































 
    volatile uint32_t INTEN;

    




























































 
    volatile uint32_t INTSTS;

    

























 
    volatile const  uint32_t STATUS;

} OTG_T;




 











































































































































   
   


 



 

typedef struct {

    























































 
    volatile uint32_t CTL;

    










 
    volatile uint32_t ENDSA;

    










 
    volatile uint32_t ENDDA;

    











 
    volatile uint32_t NEXT;

} DSCT_T;

typedef struct {
    DSCT_T DSCT[16];
    uint32_t RESERVE0[192];

    













 
    volatile uint32_t CHCTL;

    















 
    volatile  uint32_t STOP;

    














 
    volatile  uint32_t SWREQ;

    













 
    volatile const  uint32_t TRGSTS;

    











 
    volatile uint32_t PRISET;

    











 
    volatile  uint32_t PRICLR;

    










 
    volatile uint32_t INTEN;

    



























 
    volatile uint32_t INTSTS;

    











 
    volatile uint32_t ABTSTS;

    











 
    volatile uint32_t TDSTS;

    











 
    volatile uint32_t SCATSTS;

    










 
    volatile const  uint32_t TACTSTS;
    uint32_t RESERVE1[3];


    











 
    volatile uint32_t SCATBA;

    












 
    volatile uint32_t TOC0_1;

    












 
    volatile uint32_t TOC2_3;

    












 
    volatile uint32_t TOC4_5;

    












 
    volatile uint32_t TOC6_7;

    












 
    volatile uint32_t TOC8_9;

    












 
    volatile uint32_t TOC10_11;

    












 
    volatile uint32_t TOC12_13;

    












 
    volatile uint32_t TOC14_15;
    uint32_t RESERVE2[8];


    




















































 
    volatile uint32_t REQSEL0_3;

    


























 
    volatile uint32_t REQSEL4_7;

    


























 
    volatile uint32_t REQSEL8_11;

    


























 
    volatile uint32_t REQSEL12_15;

} PDMA_T;




 


















































































































































































   
   


 



 

typedef struct {


    












































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t TXDAT0;

    









 
    volatile uint32_t TXDAT1;

    









 
    volatile uint32_t TXDAT2;

    









 
    volatile uint32_t TXDAT3;

    









 
    volatile const  uint32_t RXDAT;

    

















































































 
    volatile uint32_t STATUS;

    


















 
    volatile uint32_t INTSTS;

} PS2_T;




 












































































   
   


 



 

typedef struct {


    





















 
    volatile uint32_t CLKPSC;

    
























 
    volatile uint32_t CLKDIV;

    









































 
    volatile uint32_t CTL;

    










 
    volatile uint32_t CNTEN;

    
























 
    volatile uint32_t PERIOD[6];

    





















 
    volatile uint32_t CMPDAT[6];

    









 
    volatile const  uint32_t CNT[6];

    












 
    volatile uint32_t MSKEN;

    











 
    volatile uint32_t MSK;

    



































 
    volatile uint32_t DTCTL;

    



























 
    volatile uint32_t TRGADCTL;

    


























 
    volatile uint32_t TRGADCSTS;

    























































 
    volatile uint32_t BRKCTL;

    
















 
    volatile uint32_t INTCTL;

    

























 
    volatile uint32_t INTEN;

    







































 
    volatile uint32_t INTSTS;

    










 
    volatile uint32_t POEN;

    






















 
    volatile uint32_t CAPCTL;

    












 
    volatile uint32_t CAPINEN;

    












 
    volatile const  uint32_t CAPSTS;
    uint32_t RESERVE0[1];


    








 
    volatile const  uint32_t RCAPDAT0;

    








 
    volatile const  uint32_t FCAPDAT0;

    








 
    volatile const  uint32_t RCAPDAT1;

    








 
    volatile const  uint32_t FCAPDAT1;

    








 
    volatile const  uint32_t RCAPDAT2;

    








 
    volatile const  uint32_t FCAPDAT2;

    








 
    volatile const  uint32_t RCAPDAT3;

    








 
    volatile const  uint32_t FCAPDAT3;

    








 
    volatile const  uint32_t RCAPDAT4;

    








 
    volatile const  uint32_t FCAPDAT4;

    








 
    volatile const  uint32_t RCAPDAT5;

    








 
    volatile const  uint32_t FCAPDAT5;
    uint32_t RESERVE1[8];


    










 
    volatile const  uint32_t SBS[6];

} PWM_T;




 








































































































































































































































































































































   
   


 



 

typedef struct {


    














 
    volatile uint32_t CNT;

    








 
    volatile uint32_t CNTHOLD;

    








 
    volatile uint32_t CNTLATCH;

    









 
    volatile uint32_t CNTCMP;
    uint32_t RESERVE0[1];


    








 
    volatile uint32_t CNTMAX;

    




















































































 
    volatile uint32_t CTR;
    uint32_t RESERVE1[4];


    
































 
    volatile uint32_t STATUS;

} QEI_T;




 

































































































   
   


 



 

typedef struct {

    














 
    volatile uint32_t INIT;

    












 
    volatile  uint32_t RWEN;

    










 
    volatile uint32_t FREQADJ;

    












 
    volatile uint32_t TIME;

    












 
    volatile uint32_t CAL;

    










 
    volatile uint32_t CLKFMT;

    















 
    volatile uint32_t WEEKDAY;

    












 
    volatile uint32_t TALM;

    












 
    volatile uint32_t CALM;

    









 
    volatile const  uint32_t LEAPYEAR;

    












 
    volatile uint32_t INTEN;

    














 
    volatile uint32_t INTSTS;

    

















 
    volatile uint32_t TICK;
    uint32_t RESERVE0[2];


    
















 
    volatile uint32_t SPRCTL;

    










 
    volatile uint32_t SPR[24];
    uint32_t RESERVE1[28];


    






























 
    volatile uint32_t TAMPCTL;

    














 
    volatile uint32_t TAMPSTS;
    uint32_t RESERVE2[3];


    





















 
    volatile uint32_t TAMP0PCTL;

    





















 
    volatile uint32_t TAMP1PCTL;

    





















 
    volatile uint32_t LXTIPCTL;

    





















 
    volatile uint32_t LXTOPCTL;
    uint32_t RESERVE3[3];


    












 
    volatile uint32_t TAMSK;

    












 
    volatile uint32_t CAMSK;

} RTC_T;




 























































































































































































































































   
   


 



 

typedef struct {


    












 
    volatile uint32_t DAT;

    



























































































 
    volatile uint32_t CTL;

    































































































 
    volatile uint32_t ALTCTL;

    









 
    volatile uint32_t EGT;

    











 
    volatile uint32_t RXTOUT;

    















 
    volatile uint32_t ETUCTL;

    



















































 
    volatile uint32_t INTEN;

    
















































 
    volatile  uint32_t INTSTS;

    






















































































 
    volatile  uint32_t STATUS;

    


































































 
    volatile uint32_t PINCTL;

    











 
    volatile uint32_t TMRCTL0;

    











 
    volatile uint32_t TMRCTL1;

    











 
    volatile uint32_t TMRCTL2;

    


























 
    volatile uint32_t UARTCTL;

    








 
    volatile const  uint32_t TMRDAT0;

    










 
    volatile const  uint32_t TMRDAT1_2;

} SC_T;




 










































































































































































































































































































   
   


 



 

typedef struct {

    








 
    uint32_t FB[32];
    uint32_t RESERVE0[224];


    

























 
    volatile uint32_t DMACTL;
    uint32_t RESERVE1[1];


    













 
    volatile uint32_t DMASA;

    









 
    volatile const  uint32_t DMABCNT;

    












 
    volatile uint32_t DMAINTEN;

    















 
    volatile uint32_t DMAINTSTS;
    uint32_t RESERVE2[250];


    














 
    volatile uint32_t GCTL;

    









 
    volatile uint32_t GINTEN;

    












 
    volatile const  uint32_t GINTSTS;
    uint32_t RESERVE3[5];


    






























































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t CMDARG;

    












































 
    volatile uint32_t INTEN;

    

















































































 
    volatile  uint32_t INTSTS;

    









 
    volatile const  uint32_t RESP0;

    









 
    volatile const  uint32_t RESP1;

    










 
    volatile uint32_t BLEN;

    












 
    volatile uint32_t TOUT;

} SDH_T;




 












































































































































































   
   


 



 

typedef struct {


    


















































































 
    volatile uint32_t CTL;

    












 
    volatile uint32_t CLKDIV;

    























































 
    volatile uint32_t SSCTL;

    





















 
    volatile uint32_t PDMACTL;

    










































 
    volatile uint32_t FIFOCTL;

    
































































































 
    volatile  uint32_t STATUS;
    uint32_t RESERVE0[2];


    












 
    volatile  uint32_t TX;
    uint32_t RESERVE1[3];


    











 
    volatile const  uint32_t RX;

} SPI_T;




 



























































































































































































   
   


 



 

typedef struct {


    









 
    volatile const  uint32_t PDID;

    


































 
    volatile uint32_t RSTSTS;

    











































































 
    volatile uint32_t IPRST0;

    

















































































 
    volatile uint32_t IPRST1;

    







































 
    volatile uint32_t IPRST2;
    uint32_t RESERVE0[1];


    






















































 
    volatile uint32_t BODCTL;

    












 
    volatile uint32_t TEMPCTL;

    











 
    volatile const  uint32_t VCID;

    













 
    volatile uint32_t PORCTL;

    



















 
    volatile uint32_t VREFCTL;

    















 
    volatile uint32_t USBPHY;

    














 
    volatile uint32_t GPA_MFPL;

    














 
    volatile uint32_t GPA_MFPH;

    














 
    volatile uint32_t GPB_MFPL;

    














 
    volatile uint32_t GPB_MFPH;

    














 
    volatile uint32_t GPC_MFPL;

    














 
    volatile uint32_t GPC_MFPH;

    














 
    volatile uint32_t GPD_MFPL;

    














 
    volatile uint32_t GPD_MFPH;

    














 
    volatile uint32_t GPE_MFPL;

    














 
    volatile uint32_t GPE_MFPH;

    














 
    volatile uint32_t GPF_MFPL;

    














 
    volatile uint32_t GPF_MFPH;

    














 
    volatile uint32_t GPG_MFPL;

    














 
    volatile uint32_t GPG_MFPH;

    














 
    volatile uint32_t GPH_MFPL;

    














 
    volatile uint32_t GPH_MFPH;

    














 
    volatile uint32_t GPI_MFPL;

    














 
    volatile uint32_t GPI_MFPH;
    uint32_t RESERVE1[18];


    









 
    volatile uint32_t SRAM_INTCTL;

    












 
    volatile uint32_t SRAM_STATUS;

    







 
    volatile const  uint32_t SRAM0_ERRADDR;

    








 
    volatile const  uint32_t SRAM1_ERRADDR;
    uint32_t RESERVE2[8];


    
































 
    volatile uint32_t IRCTCTL;

    
















 
    volatile uint32_t IRCTIEN;

    























 
    volatile uint32_t IRCTISTS;
    uint32_t RESERVE3[1];


    




























 
    volatile  uint32_t REGLCTL;

} SYS_T;




 






















































































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    




























































 
    volatile uint32_t CTL;

    













 
    volatile uint32_t CMP;

    
















 
    volatile uint32_t INTSTS;

    











 
    volatile const  uint32_t CNT;

    








 
    volatile const  uint32_t CAP;

    





































 
    volatile uint32_t EXTCTL;

    












 
    volatile uint32_t EINTSTS;

} TIMER_T;




 













































































   
   


 



 

typedef struct {


    













 
    volatile uint32_t DAT;

    


















































 
    volatile uint32_t INTEN;

    






























































 
    volatile uint32_t FIFO;

    



































 
    volatile uint32_t LINE;

    



















 
    volatile uint32_t MODEM;

    















 
    volatile uint32_t MODEMSTS;

    


























































 
    volatile uint32_t FIFOSTS;

    




































































































 
    volatile uint32_t INTSTS;

    















 
    volatile uint32_t TOUT;

    





















 
    volatile uint32_t BAUD;

    













 
    volatile uint32_t IRDA;

    






































 
    volatile uint32_t ALTCTL;

    












 
    volatile uint32_t FUNCSEL;

    












































































 
    volatile uint32_t LINCTL;

    













































 
    volatile uint32_t LINSTS;

    














 
    volatile uint32_t LINDEBUG;

    






 
    volatile uint32_t SCCTL;

    






 
    volatile uint32_t SCSTATUS;

} UART_T;




 











































































































































































































































































































































   
   


 



 

typedef struct {
    










 
    volatile const  uint32_t HcRev;

    



































 
    volatile uint32_t HcControl;

    


















 
    volatile uint32_t HcComSts;

    




















 
    volatile uint32_t HcIntSts;

    





























 
    volatile uint32_t HcIntEn;

    




























 
    volatile uint32_t HcIntDis;

    








 
    volatile uint32_t HcHCCA;

    








 
    volatile uint32_t HcPerCED;

    








 
    volatile uint32_t HcCtrHED;

    








 
    volatile uint32_t HcCtrCED;

    








 
    volatile uint32_t HcBlkHED;

    








 
    volatile uint32_t HcBlkCED;

    








 
    volatile uint32_t HcDoneH;

    













 
    volatile uint32_t HcFmIntv;

    












 
    volatile const  uint32_t HcFmRem;

    









 
    volatile const  uint32_t HcFNum;

    








 
    volatile uint32_t HcPerSt;

    










 
    volatile uint32_t HcLSTH;

    






































 
    volatile uint32_t HcRhDeA;

    














 
    volatile uint32_t HcRhDeB;

    






























 
    volatile uint32_t HcRhSts;

    





































































 
    volatile uint32_t HcRhPrt[2];

    uint32_t RESERVE0[105];


    










 
    volatile uint32_t MiscCtrl;

    



































 
    volatile uint32_t OpModEn;

} USBH_T;




 
































































































































































































































































   
   


 



 

typedef struct {


    
































































 
    volatile const  uint32_t GINTSTS;
    uint32_t RESERVE0[1];


    






























































 
    volatile uint32_t GINTEN;
    uint32_t RESERVE1[1];


    











































 
    volatile uint32_t BUSINTSTS;

    






































 
    volatile uint32_t BUSINTEN;

    
















 
    volatile uint32_t OPER;

    










 
    volatile const  uint32_t FRAMECNT;

    









 
    volatile uint32_t FADDR;

    
















 
    volatile uint32_t TEST;

    union {

        









 
        volatile uint32_t CEPDAT;
         
        volatile uint8_t  CEPDAT_BYTE;

    };

    
































 
    volatile uint32_t CEPCTL;

    













































 
    volatile uint32_t CEPINTEN;

    




























































 
    volatile uint32_t CEPINTSTS;

    










 
    volatile uint32_t CEPTXCNT;

    








 
    volatile const  uint32_t CEPRXCNT;

    








 
    volatile const  uint32_t CEPDATCNT;

    







































 
    volatile const  uint32_t SETUP1_0;

    












 
    volatile const  uint32_t SETUP3_2;

    












 
    volatile const  uint32_t SETUP5_4;

    












 
    volatile const  uint32_t SETUP7_6;

    








 
    volatile uint32_t CEPBUFSTART;

    








 
    volatile uint32_t CEPBUFEND;

    




















 
    volatile uint32_t DMACTL;

    








 
    volatile uint32_t DMACNT;

    union {

        









 
        volatile uint32_t EPADAT;
         
        volatile uint8_t  EPADAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPAINTSTS;

    


























































 
    volatile uint32_t EPAINTEN;

    










 
    volatile const  uint32_t EPADATCNT;

    














































 
    volatile uint32_t EPARSPCTL;

    








 
    volatile uint32_t EPAMPS;

    









 
    volatile uint32_t EPATXCNT;

    























 
    volatile uint32_t EPACFG;

    








 
    volatile uint32_t EPABUFSTART;

    








 
    volatile uint32_t EPABUFEND;

    union {

        









 
        volatile uint32_t EPBDAT;
         
        volatile uint8_t  EPBDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPBINTSTS;

    


























































 
    volatile uint32_t EPBINTEN;

    










 
    volatile const  uint32_t EPBDATCNT;

    














































 
    volatile uint32_t EPBRSPCTL;

    








 
    volatile uint32_t EPBMPS;

    









 
    volatile uint32_t EPBTXCNT;

    























 
    volatile uint32_t EPBCFG;

    








 
    volatile uint32_t EPBBUFSTART;

    








 
    volatile uint32_t EPBBUFEND;

    union {

        









 
        volatile uint32_t EPCDAT;
         
        volatile uint8_t  EPCDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPCINTSTS;

    


























































 
    volatile uint32_t EPCINTEN;

    










 
    volatile const  uint32_t EPCDATCNT;

    














































 
    volatile uint32_t EPCRSPCTL;

    








 
    volatile uint32_t EPCMPS;

    









 
    volatile uint32_t EPCTXCNT;

    























 
    volatile uint32_t EPCCFG;

    








 
    volatile uint32_t EPCBUFSTART;

    








 
    volatile uint32_t EPCBUFEND;

    union {

        









 
        volatile uint32_t EPDDAT;
         
        volatile uint8_t  EPDDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPDINTSTS;

    


























































 
    volatile uint32_t EPDINTEN;

    










 
    volatile const  uint32_t EPDDATCNT;

    














































 
    volatile uint32_t EPDRSPCTL;

    








 
    volatile uint32_t EPDMPS;

    









 
    volatile uint32_t EPDTXCNT;

    























 
    volatile uint32_t EPDCFG;

    








 
    volatile uint32_t EPDBUFSTART;

    








 
    volatile uint32_t EPDBUFEND;

    union {

        









 
        volatile uint32_t EPEDAT;
         
        volatile uint8_t  EPEDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPEINTSTS;

    


























































 
    volatile uint32_t EPEINTEN;

    










 
    volatile const  uint32_t EPEDATCNT;

    














































 
    volatile uint32_t EPERSPCTL;

    








 
    volatile uint32_t EPEMPS;

    









 
    volatile uint32_t EPETXCNT;

    























 
    volatile uint32_t EPECFG;

    








 
    volatile uint32_t EPEBUFSTART;

    








 
    volatile uint32_t EPEBUFEND;

    union {

        









 
        volatile uint32_t EPFDAT;
         
        volatile uint8_t  EPFDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPFINTSTS;

    


























































 
    volatile uint32_t EPFINTEN;

    










 
    volatile const  uint32_t EPFDATCNT;

    














































 
    volatile uint32_t EPFRSPCTL;

    








 
    volatile uint32_t EPFMPS;

    









 
    volatile uint32_t EPFTXCNT;

    























 
    volatile uint32_t EPFCFG;

    








 
    volatile uint32_t EPFBUFSTART;

    








 
    volatile uint32_t EPFBUFEND;

    union {

        









 
        volatile uint32_t EPGDAT;
         
        volatile uint8_t  EPGDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPGINTSTS;

    


























































 
    volatile uint32_t EPGINTEN;

    










 
    volatile const  uint32_t EPGDATCNT;

    














































 
    volatile uint32_t EPGRSPCTL;

    








 
    volatile uint32_t EPGMPS;

    









 
    volatile uint32_t EPGTXCNT;

    























 
    volatile uint32_t EPGCFG;

    








 
    volatile uint32_t EPGBUFSTART;

    








 
    volatile uint32_t EPGBUFEND;

    union {

        









 
        volatile uint32_t EPHDAT;
         
        volatile uint8_t  EPHDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPHINTSTS;

    


























































 
    volatile uint32_t EPHINTEN;

    










 
    volatile const  uint32_t EPHDATCNT;

    














































 
    volatile uint32_t EPHRSPCTL;

    








 
    volatile uint32_t EPHMPS;

    









 
    volatile uint32_t EPHTXCNT;

    























 
    volatile uint32_t EPHCFG;

    








 
    volatile uint32_t EPHBUFSTART;

    








 
    volatile uint32_t EPHBUFEND;

    union {

        









 
        volatile uint32_t EPIDAT;
         
        volatile uint8_t  EPIDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPIINTSTS;

    


























































 
    volatile uint32_t EPIINTEN;

    










 
    volatile const  uint32_t EPIDATCNT;

    














































 
    volatile uint32_t EPIRSPCTL;

    








 
    volatile uint32_t EPIMPS;

    









 
    volatile uint32_t EPITXCNT;

    























 
    volatile uint32_t EPICFG;

    








 
    volatile uint32_t EPIBUFSTART;

    








 
    volatile uint32_t EPIBUFEND;

    union {

        









 
        volatile uint32_t EPJDAT;
         
        volatile uint8_t  EPJDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPJINTSTS;

    


























































 
    volatile uint32_t EPJINTEN;

    










 
    volatile const  uint32_t EPJDATCNT;

    














































 
    volatile uint32_t EPJRSPCTL;

    








 
    volatile uint32_t EPJMPS;

    









 
    volatile uint32_t EPJTXCNT;

    























 
    volatile uint32_t EPJCFG;

    








 
    volatile uint32_t EPJBUFSTART;

    








 
    volatile uint32_t EPJBUFEND;

    union {

        









 
        volatile uint32_t EPKDAT;
         
        volatile uint8_t  EPKDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPKINTSTS;

    


























































 
    volatile uint32_t EPKINTEN;

    










 
    volatile const  uint32_t EPKDATCNT;

    














































 
    volatile uint32_t EPKRSPCTL;

    








 
    volatile uint32_t EPKMPS;

    









 
    volatile uint32_t EPKTXCNT;

    























 
    volatile uint32_t EPKCFG;

    








 
    volatile uint32_t EPKBUFSTART;

    








 
    volatile uint32_t EPKBUFEND;

    union {

        









 
        volatile uint32_t EPLDAT;
         
        volatile uint8_t  EPLDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPLINTSTS;

    


























































 
    volatile uint32_t EPLINTEN;

    










 
    volatile const  uint32_t EPLDATCNT;

    














































 
    volatile uint32_t EPLRSPCTL;

    








 
    volatile uint32_t EPLMPS;

    









 
    volatile uint32_t EPLTXCNT;

    























 
    volatile uint32_t EPLCFG;

    








 
    volatile uint32_t EPLBUFSTART;

    








 
    volatile uint32_t EPLBUFEND;

    uint32_t RESERVE2[303];


    









 
    volatile uint32_t DMAADDR;

    


















 
    volatile uint32_t PHYCTL;

} USBD_T;




 



































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    

























































 
    volatile uint32_t CTL;

    














 
    volatile uint32_t ALTCTL;

} WDT_T;




 


































   
   


 



 

typedef struct {


    










 
    volatile  uint32_t RLDCNT;

    








































 
    volatile uint32_t CTL;

    
















 
    volatile uint32_t STATUS;

    








 
    volatile const  uint32_t CNT;

} WWDT_T;




 




























   
   


#pragma no_anon_unions



   




 
 






 
#line 32418 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 32443 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 32468 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

   





 

#line 32500 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"







#line 32548 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
   




 

typedef volatile unsigned char  vu8;        
typedef volatile unsigned short vu16;       
typedef volatile unsigned long  vu32;       





 







 







 








 







 








 







 







 






 








 







 








 







 







 






 



   

 
 
 



 











 
#line 32734 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 










   


 
 
 
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
 








 











 



 



 


#line 41 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 
#line 94 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 
#line 109 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 


 
 
 
#line 127 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 








 
 
 






 















#line 171 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 179 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 188 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 198 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 208 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 216 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 224 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 232 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 240 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 248 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 256 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

















































#line 311 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









#line 327 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 337 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"






























#line 373 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 381 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

















#line 405 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"



#line 415 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 424 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 435 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 445 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 453 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 461 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"















#line 486 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

#line 493 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









#line 509 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 518 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 528 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 537 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 547 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 555 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 563 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 573 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 582 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 590 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 598 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 606 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
















































































#line 692 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 700 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 708 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
















#line 731 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









































































































































































































































































































































   



 

#line 1088 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

void SYS_ClearResetSrc(uint32_t u32Src);
uint32_t SYS_GetBODStatus(void);
uint32_t SYS_GetResetSrc(void);
uint32_t SYS_IsRegLocked(void);
void SYS_LockReg(void);
void SYS_UnlockReg(void);
uint32_t  SYS_ReadPDID(void);
void SYS_ResetChip(void);
void SYS_ResetCPU(void);
void SYS_ResetModule(uint32_t u32ModuleIndex);
void SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
void SYS_DisableBOD(void);

   

   

   







 
#line 32753 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"
 








 











 



 




 






 
 
 










#line 62 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"







 
 
 




 
 
 
#line 85 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

























 
 
 





















#line 140 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 147 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 154 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 161 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"














 
 
 




































 
 
 








































 
 
 






 
 
 





 
 
 



 
 
 





 
 
 
#line 300 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"
 
 
 
#line 314 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 345 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 368 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

   




 

void CLK_DisableCKO(void);
void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
void CLK_PowerDown(void);
void CLK_Idle(void);
uint32_t CLK_GetHXTFreq(void);
uint32_t CLK_GetLXTFreq(void);
uint32_t CLK_GetHCLKFreq(void);
uint32_t CLK_GetPCLKFreq(void);
uint32_t CLK_GetCPUFreq(void);
uint32_t CLK_GetPLLClockFreq(void);
uint32_t CLK_SetCoreClock(uint32_t u32Hclk);
void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
void CLK_EnableXtalRC(uint32_t u32ClkMask);
void CLK_DisableXtalRC(uint32_t u32ClkMask);
void CLK_EnableModuleClock(uint32_t u32ModuleIdx);
void CLK_DisableModuleClock(uint32_t u32ModuleIdx);
uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
void CLK_DisablePLL(void);
void CLK_SysTickDelay(uint32_t us);
uint32_t CLK_WaitClockReady(uint32_t u32ClkMask);

   

   

   







 
#line 32754 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"
 








 











 



 



 

 
 
 
#line 85 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"


   




 












































 
#line 146 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"







 








 








 








 









 








 








 








 








 














 








































 






 






 








 








 



void ACMP_Open(ACMP_T *acmp, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
void ACMP_Close(ACMP_T *acmp, uint32_t u32ChNum);

   

   

   







 
#line 32756 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"
 








 











 



 



 

#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"

   




 







 











 











 











 










 










 







 







 
















 
#line 179 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"





 
















 
#line 211 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"





 








 







 







 










 







 







 







 


void ADC_Open(ADC_T *adc,
              uint32_t u32InputMode,
              uint32_t u32OpMode,
              uint32_t u32ChMask);
void ADC_Close(ADC_T *adc);
void ADC_EnableHWTrigger(ADC_T *adc,
                         uint32_t u32Source,
                         uint32_t u32Param);
void ADC_DisableHWTrigger(ADC_T *adc);
void ADC_SetExtraSampleTime(ADC_T *adc,
                            uint32_t u32ChNum,
                            uint32_t u32SampleTime);
void ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
void ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);



   

   

   







 
#line 32757 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"
 









 










 



 



 

 
 
 
#line 42 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"

 
 
 


                                                                       





















#line 76 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"

 
 
 






static uint32_t u32EscapeFrame = 0;
 
 
 





   





 








 















 









 


void CAP_Open(uint32_t u32InFormat, uint32_t u32OutFormet);
void CAP_SetCroppingWindow(uint32_t u32VStart,uint32_t u32HStart, uint32_t u32Height, uint32_t u32Width);
void CAP_SetPacketBuf(uint32_t  u32Address );
void CAP_SetPlanarBuf(uint32_t u32YAddr, uint32_t u32UAddr, uint32_t u32VAddr);
void CAP_Close(void);
void CAP_EnableInt(uint32_t u32IntMask);
void CAP_DisableInt(uint32_t u32IntMask);
void CAP_Start(void);
void CAP_Stop(uint32_t u32FrameComplete);
void CAP_SetPacketScaling(uint32_t u32VNumerator, uint32_t u32VDenominator, uint32_t u32HNumerator, uint32_t u32HDenominator);
void CAP_SetPlanarScaling(uint32_t u32VNumerator, uint32_t u32VDenominator, uint32_t u32HNumerator, uint32_t u32HDenominator);
void CAP_SetPacketStride(uint32_t u32Stride );
void CAP_SetPlanarStride(uint32_t u32Stride );
void CAP_EnableMotionDet(uint32_t u32Freq, uint32_t u32BlockSize, uint32_t u32Format, uint32_t u32Threshold,  uint32_t u32YDetAddr, uint32_t u32DetAddr);
void CAP_DisableMotionDet(void);

   



   

   







 
#line 32758 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"
 








 










 



 




 













#line 52 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"












#line 72 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"














   




 

 
 
 

#line 117 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"

 
 
 

void PRNG_Open(uint32_t u32KeySize, uint32_t u32SeedReload, uint32_t u32Seed);
void PRNG_Start(void);
void PRNG_Read(uint32_t u32RandKey[]);
void AES_Open(uint32_t u32Channel, uint32_t u32EncDec, uint32_t u32OpMode, uint32_t u32KeySize, uint32_t u32SwapType);
void AES_Start(int32_t u32Channel, uint32_t u32DMAMode);
void AES_SetKey(uint32_t u32Channel, uint32_t au32Keys[], uint32_t u32KeySize);
void AES_SetInitVect(uint32_t u32Channel, uint32_t au32IV[]);
void AES_SetDMATransfer(uint32_t u32Channel, uint32_t u32SrcAddr, uint32_t u32DstAddr, uint32_t u32TransCnt);
void TDES_Open(uint32_t u32Channel, uint32_t u32EncDec, uint32_t u32OpMode, uint32_t u32SwapType);
void TDES_Start(int32_t u32Channel, uint32_t u32DMAMode);
void TDES_SetKey(uint32_t u32Channel, uint8_t au8Keys[3][8]);
void TDES_SetInitVect(uint32_t u32Channel, uint32_t u32IVH, uint32_t u32IVL);
void TDES_SetDMATransfer(uint32_t u32Channel, uint32_t u32SrcAddr, uint32_t u32DstAddr, uint32_t u32TransCnt);
void SHA_Open(uint32_t u32OpMode, uint32_t u32SwapType);
void SHA_Start(uint32_t u32DMAMode);
void SHA_SetDMATransfer(uint32_t u32SrcAddr, uint32_t u32TransCnt);
void SHA_Read(uint32_t u32Digest[]);


   

   

   







 

#line 32759 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"
 








 











 



 



 


 
 
 




 
 
 




 
 
 





 
 
 



#line 69 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"

 
 
 
#line 99 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"

   



 










 











 











 











 











 











 











 











 











 












 












 












 












 











 




void PDMA_Open(uint32_t u32Mask);
void PDMA_Close(void);
void PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
void PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
void PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
void PDMA_SetBurstType(uint32_t u32Ch, uint32_t u32BurstType, uint32_t u32BurstSize);
void PDMA_SetTimeOut(uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
void PDMA_Trigger(uint32_t u32Ch);
void PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
void PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);



   

   

   







 
#line 32760 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"
 








 











 



 



 

 



#line 42 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 53 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 75 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"


 





 



 



 



 
#line 102 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

#line 110 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

   




 
void EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
void EBI_Close(uint32_t u32Bank);
void EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
void EBI_EnableCrypto(uint32_t u32Bank, uint32_t *u32Key);
void EBI_DisbleCrypto(uint32_t u32Bank);


   

   

   







 
#line 32761 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\emac.h"
 








 











 



 



 







   




 







 








 







 








 







 








 









 







 







 







 







 









 







 



void EMAC_Open(uint8_t *pu8MacAddr);
void EMAC_Close(void);
void EMAC_SetMacAddr(uint8_t *pu8MacAddr);
void EMAC_EnableCamEntry(uint32_t u32Entry, uint8_t *pu8MacAddr);
void EMAC_DisableCamEntry(uint32_t u32Entry);

uint32_t EMAC_RecvPkt(uint8_t *pu8Data, uint32_t *pu32Size);
uint32_t EMAC_RecvPktTS(uint8_t *pu8Data, uint32_t *pu32Size, uint32_t *pu32Sec, uint32_t *pu32Nsec);
void EMAC_RecvPktDone(void);

uint32_t EMAC_SendPkt(uint8_t *pu8Data, uint32_t u32Size);
uint32_t EMAC_SendPktDone(void);
uint32_t EMAC_SendPktDoneTS(uint32_t *pu32Sec, uint32_t *pu32Nsec);

void EMAC_EnableTS(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_DisableTS(void);
void EMAC_GetTime(uint32_t *pu32Sec, uint32_t *pu32Nsec);
void EMAC_SetTime(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_UpdateTime(uint32_t u32Neg, uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_EnableAlarm(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_DisableAlarm(void);



   

   

   







 
#line 32762 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"
 









 










 



 




 


 
 
 









 
 
 
#line 59 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"





   




 

 
 
 

#line 87 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"

 
 
 

extern void FMC_SetBootSource(int32_t i32BootSrc);
extern void FMC_Close(void);
extern void FMC_DisableAPUpdate(void);
extern void FMC_DisableConfigUpdate(void);
extern void FMC_DisableLDUpdate(void);
extern void FMC_EnableAPUpdate(void);
extern void FMC_EnableConfigUpdate(void);
extern void FMC_EnableLDUpdate(void);
extern int32_t FMC_Erase(uint32_t u32PageAddr);
extern int32_t FMC_GetBootSource(void);
extern void FMC_Open(void);
extern uint32_t FMC_Read(uint32_t u32Addr);
extern void FMC_Read_64(uint32_t u32Addr, uint32_t *u32Data0, uint32_t *u32Data1);
extern uint32_t FMC_ReadCID(void);
extern uint32_t FMC_ReadDID(void);
extern uint32_t FMC_ReadPID(void);
extern uint32_t FMC_ReadUCID(uint32_t u32Index);
extern uint32_t FMC_ReadUID(uint32_t u32Index);
extern uint32_t FMC_ReadDataFlashBaseAddr(void);
extern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
extern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
extern void FMC_Write_64(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1);
extern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
extern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
extern uint32_t FMC_CRC8(uint32_t au32Data[], int i32Count);


   

   

   







 
#line 32763 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"
 








 











 



 



 


 
 
 





 
 
 






 
 
 



 
 
 






#line 81 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"














 
#line 113 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 130 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 147 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 164 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 181 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 198 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 215 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 232 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 249 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

   



 










 











 











 











 











 











 











 












 



















 










 











 











 













 












 














 












 













 












 



void GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
void GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
void GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);



   

   

   







 
#line 32764 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2c.h"
 








 











 



 



 









   




 







 







 







 







 







 








 







 









 









 


uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
void I2C_Close(I2C_T *i2c);
void I2C_ClearTimeoutFlag(I2C_T *i2c);
void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
void I2C_DisableInt(I2C_T *i2c);
void I2C_EnableInt(I2C_T *i2c);
uint32_t I2C_GetBusClockFreq(I2C_T *i2c);
uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
uint32_t I2C_GetIntFlag(I2C_T *i2c);
uint32_t I2C_GetStatus(I2C_T *i2c);
uint32_t I2C_GetData(I2C_T *i2c);
void I2C_SetData(I2C_T *i2c, uint8_t u8Data);
void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
void I2C_DisableTimeout(I2C_T *i2c);
void I2C_EnableWakeup(I2C_T *i2c);
void I2C_DisableWakeup(I2C_T *i2c);

   

   

   







 
#line 32765 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pwm.h"
 








 











 



 



 
#line 68 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pwm.h"

   




 






 







 







 







 







 







 









 








 








 










 











 















 











 











 












 




uint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
                                 uint32_t u32ChannelNum,
                                 uint32_t u32Frequency,
                                 uint32_t u32DutyCycle);
uint32_t PWM_ConfigCaptureChannel (PWM_T *pwm,
                                   uint32_t u32ChannelNum,
                                   uint32_t u32UnitTimeNsec,
                                   uint32_t u32CaptureEdge);
void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableFaultBrake(PWM_T *pwm,
                          uint32_t u32ChannelMask,
                          uint32_t u32LevelMask,
                          uint32_t u32BrakeSource);
void PWM_ClearFaultBrakeFlag(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);



   

   

   







 
#line 32766 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"
 








 












 



 




 
















#line 57 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"

#line 65 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"




   




 



 
typedef struct {
    uint32_t u32Year;           
    uint32_t u32Month;          
    uint32_t u32Day;            
    uint32_t u32DayOfWeek;      
    uint32_t u32Hour;           
    uint32_t u32Minute;         
    uint32_t u32Second;         
    uint32_t u32TimeScale;      
    uint32_t u32AmPm;           
} S_RTC_TIME_DATA_T;

   







 









 










 










 









 









 









 









 









 









 




void RTC_Open(S_RTC_TIME_DATA_T *sPt);
void RTC_Close(void);
void RTC_32KCalibration(int32_t i32FrequencyX100);
void RTC_SetTickPeriod(uint32_t u32TickSelection);
void RTC_EnableInt(uint32_t u32IntFlagMask);
void RTC_DisableInt(uint32_t u32IntFlagMask);
uint32_t RTC_GetDayOfWeek(void);
void RTC_DisableTamperDetection(uint32_t u32PinNumber);
void RTC_EnableTamperDetection(uint32_t u32PinNumber, uint32_t u32PinCondition, uint32_t u32IntFlag, uint32_t u32ClearFlag, uint32_t u32DestroyEn);
void RTC_EnableSpareAccess(void);
void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);



   


   

   









 



#line 32767 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"
 








 











 



 



 
#line 37 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"

#line 48 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"


   




 


















 



















 








 
#line 112 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"








 
#line 129 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 145 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 161 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"






 








 









 







 
static __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
{
    while(sc->CTL & (0x1ul << (30)));
    if(u32Count == 0) {       
        sc->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));
    } else {
        sc->CTL = (sc->CTL & ~(0x7ul << (20))) | ((u32Count - 1) << (20)) | (0x1ul << (23));
    }
}






 
static __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
{
    while(sc->CTL & (0x1ul << (30)));
    if(u32Count == 0) {       
        sc->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));
    } else {
        sc->CTL = (sc->CTL & ~(0x7ul << (16))) | ((u32Count - 1) << (16)) | (0x1ul << (19));
    }
}


uint32_t SC_IsCardInserted(SC_T *sc);
void SC_ClearFIFO(SC_T *sc);
void SC_Close(SC_T *sc);
void SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
void SC_ResetReader(SC_T *sc);
void SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
void SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
void SC_StopAllTimer(SC_T *sc);
void SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
void SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);


   

   

   







 
#line 32768 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\scuart.h"
 








 











 



 



 













   




 

 






 









 









 








 









 









 



 






 









 










 










 









 


 











 












 














 











 










 











 


void SCUART_Close(SC_T* sc);
uint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
uint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
uint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
void SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
void SCUART_Write(SC_T* sc,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);

   

   

   







 
#line 32769 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\spi.h"
 








 











 



 



 














#line 56 "..\\..\\..\\..\\Library\\StdDriver\\inc\\spi.h"


   




 








 







 







 







 







 







 







 








 








 







 









 









 









 







 








 







 
static __inline void SPI_SET_SS0_HIGH(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x1);
}






 
static __inline void SPI_SET_SS0_LOW(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL &= ~(0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x1);
}






 
static __inline void SPI_SET_SS1_HIGH(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x2);
}






 
static __inline void SPI_SET_SS1_LOW(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x2);
}







 








 









 








 








 









 
static __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
{
    if(u32Width == 32)
        u32Width = 0;

    spi->CTL = (spi->CTL & ~(0x1ful << (8))) | (u32Width << (8));
}








 







 







 







 







 







 







 







 







 







 







 







 







 







 







 








 








 


uint32_t SPI_Open(SPI_T *spi,uint32_t u32MasterSlave, uint32_t u32SPIMode,  uint32_t u32DataWidth, uint32_t u32BusClock);
void SPI_Close(SPI_T *spi);
void SPI_ClearRxFIFO(SPI_T *spi);
void SPI_ClearTxFIFO(SPI_T *spi);
void SPI_DisableAutoSS(SPI_T *spi);
void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
void SPI_SetFIFOThreshold(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
uint32_t SPI_GetBusClock(SPI_T *spi);
void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);


   

   

   







 
#line 32770 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\timer.h"
 








 











 



 



 

#line 46 "..\\..\\..\\..\\Library\\StdDriver\\inc\\timer.h"

   




 







 









 








 










 







 
static __inline void TIMER_Start(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (30));
}





 
static __inline void TIMER_Stop(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (30));
}






 
static __inline void TIMER_EnableWakeup(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (23));
}





 
static __inline void TIMER_DisableWakeup(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (23));
}






 
static __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (6));
}





 
static __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (6));
}






 
static __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (7));
}





 
static __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (7));
}





 
static __inline void TIMER_EnableInt(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (29));
}





 
static __inline void TIMER_DisableInt(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (29));
}





 
static __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (5));
}





 
static __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (5));
}







 
static __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
{
    return(timer->INTSTS & (0x1ul << (0)) ? 1 : 0);
}





 
static __inline void TIMER_ClearIntFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (0));
}







 
static __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
{
    return timer->EINTSTS;
}





 
static __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
{
    timer->EINTSTS = (0x1ul << (0));
}







 
static __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
{
    return (timer->INTSTS & (0x1ul << (1)) ? 1 : 0);
}





 
static __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (1));
}





 
static __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
{
    return timer->CAP;
}





 
static __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
{
    return timer->CNT;
}

uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
void TIMER_Close(TIMER_T *timer);
void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
void TIMER_DisableCapture(TIMER_T *timer);
void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
void TIMER_DisableEventCounter(TIMER_T *timer);
uint32_t TIMER_GetModuleClock(TIMER_T *timer);


   

   

   







 
#line 32771 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\uart.h"
 








 













 



 



 

 
 
 











 
 
 
















 
 
 



 
 
 




 
 
 





   




 











 










 











 









 










 










 









 










 











 












 












 










 










 



















 


















 





















 








 
static __inline void UART_CLEAR_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9));
    uart->MODEM &= (0x1ul << (1));
}






 
static __inline void UART_SET_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
}







 









 



void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
void UART_Close(UART_T* uart );
void UART_DisableFlowCtrl(UART_T* uart );
void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
void UART_EnableFlowCtrl(UART_T* uart );
void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
void UART_Open(UART_T* uart, uint32_t u32baudrate);
uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);


   

   

   







 




#line 32772 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"
 








 











 



 



 







#line 51 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 




 
#line 69 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 
#line 80 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 



 
#line 93 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 







 



 





 
#line 123 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 
#line 132 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"


   



 

typedef void (*CLASS_REQ)(void);
typedef void (*SET_INTERFACE_REQ)(uint32_t u32AltInterface);

 
typedef struct USBD_CMD_STRUCT {
    uint8_t  bmRequestType;
    uint8_t  bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;

} S_USBD_CMD_T;



 
typedef struct s_usbd_info {
    uint8_t *gu8DevDesc;
    uint8_t *gu8ConfigDesc;
    uint8_t *gu8StrLangDesc;
    uint8_t *gu8StrVendorDesc;
    uint8_t *gu8StrProductDesc;
    uint8_t *gu8QualDesc;
    uint8_t *gu8OtherConfigDesc;
    uint8_t *gu8HidReportDesc;

} S_USBD_INFO_T;


   


extern uint32_t volatile g_usbd_DmaDone;
extern uint32_t g_usbd_UsbAddr;
extern uint32_t g_usbd_CtrlInSize;
extern uint32_t g_usbd_ShortPacket;
extern uint32_t g_usbd_CtrlZero;
extern uint8_t g_usbd_EpHalt[];
extern S_USBD_INFO_T gsInfo;
extern S_USBD_CMD_T gUsbCmd;




 





































































   



 






 
static __inline void USBD_MemCopy(uint8_t *u8Dst, uint8_t *u8Src, int32_t i32Size)
{
    while (i32Size--) *u8Dst++ = *u8Src++;
}





 
static __inline void USBD_ResetDMA(void)
{
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACNT = 0;
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACTL = 0x80;
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACTL = 0x00;
}






 
static __inline void USBD_SetEpBufAddr(uint32_t u32Ep, uint32_t u32Base, uint32_t u32Len)
{
    if (u32Ep == 0xff) {
        ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPBUFSTART = u32Base;
        ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPBUFEND   = u32Base + u32Len - 1;
    } else {
        *((volatile uint32_t *) ((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPABUFSTART + (uint32_t)(u32Ep*0x28))) = u32Base;
        *((volatile uint32_t *) ((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPABUFEND + (uint32_t)(u32Ep*0x28))) = u32Base + u32Len - 1;
    }
}








 
static __inline void USBD_ConfigEp(uint32_t u32Ep, uint32_t u32EpNum, uint32_t u32EpType, uint32_t u32EpDir)
{
    if (u32EpType == ((uint32_t)0x00000002))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000000));
    else if (u32EpType == ((uint32_t)0x00000004))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000002));
    else if (u32EpType == ((uint32_t)0x00000006))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000004));

    *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPACFG+(uint32_t)(u32Ep*0x28)))=(u32EpType|u32EpDir|((uint32_t)0x00000001)|(u32EpNum << 4));
}








 
static __inline void USBD_SetStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;
    uint32_t u32Cfg;

    if (u32Ep == 0)
        (((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPCTL = ((uint32_t)0x00000002));

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);
    u32Cfg = *((volatile uint32_t *) (u32CfgAddr)) & 0xf7;   
    *((volatile uint32_t *) (u32CfgAddr)) = (u32Cfg | ((uint32_t)0x00000010));
}








 
static __inline void USBD_ClearStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);
    *((volatile uint32_t *) (u32CfgAddr)) = ((uint32_t)0x00000008);
}









 
static __inline uint32_t USBD_GetStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);

    return ((*((volatile uint32_t *) (u32CfgAddr))) & ((uint32_t)0x00000010));
}


 
void USBD_Open(S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
void USBD_Start(void);
void USBD_ProcessSetupPacket(void);
void USBD_StandardRequest(void);
void USBD_UpdateDeviceState(void);
void USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
void USBD_CtrlIn(void);
void USBD_CtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
void USBD_SwReset(void);



   

   

   







 
#line 32773 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wdt.h"
 








 











 



 



 
#line 39 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wdt.h"






   




 






 







 







 








 








 








 







 






 
static __inline void WDT_Close(void)
{
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL = 0;
    return;
}





 
static __inline void WDT_EnableInt(void)
{
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL |= (0x1ul << (6));
    return;
}





 
static __inline void WDT_DisableInt(void)
{
    
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL &= ~((0x1ul << (6)) | (0x1ul << (2)) | (0x1ul << (3))) ;
    return;
}

void  WDT_Open(uint32_t u32TimeoutInterval,
               uint32_t u32ResetDelay,
               uint32_t u32EnableReset,
               uint32_t u32EnableWakeup);

   

   

   







 
#line 32774 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wwdt.h"
 








 











 



 



 
#line 47 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wwdt.h"


   




 






 







 








 








 







 










 



void WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);


   

   

   







 
#line 32775 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"









 



#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
 









 






































 

















































 
#line 32785 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 15 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"








 



 



 





 



 





 



 



 
#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"

#line 73 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"

 



 



   



 
 
 
 








 
static __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == 0)
        i2s->CTL |= (0x1ul << (16));
    else
        i2s->CTL |= (0x1ul << (17));
}









 
static __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == 0)
        i2s->CTL &= ~(0x1ul << (16));
    else
        i2s->CTL &= ~(0x1ul << (17));
}






 







 







 







 







 







 







 







 







 







 







 







 










 
static __inline void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
{
    u32Ch == (0x1ul << (23)) ?
    (i2s->CTL |= (0x1ul << (23))) :
    (i2s->CTL &= ~(0x1ul << (23)));
}







 







 








 








 







 







 


uint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat, uint32_t u32AudioInterface);
void I2S_Close(I2S_T *i2s);
void I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
void I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
uint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
void I2S_DisableMCLK(I2S_T *i2s);

   


   

   



 

#line 32776 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\can.h"
 








 










 



 



 



 
typedef enum {
    CAN_STD_ID = 0,  
    CAN_EXT_ID = 1   
} E_CAN_ID_TYPE;



 
typedef enum {
    REMOTE_FRAME = 0,   
    DATA_FRAME   = 1    
} E_CAN_FRAME_TYPE;



 
typedef struct {
    uint32_t  IdType;      
    uint32_t  FrameType;   
    uint32_t  Id;          
    uint8_t   DLC;         
    uint8_t   Data[8];     
} STR_CANMSG_T;



 
typedef struct {
    uint8_t   u8Xtd;      
    uint8_t   u8Dir;      
    uint32_t  u32Id;      
    uint8_t   u8IdType;   
} STR_CANMASK_T;



 
typedef enum {
    CAN_NOTMAL_MODE = 1,  
    CAN_BASIC_MODE = 2    
} CAN_MODE_SELECT;





   




 








 









 









 









 










 



 
 
 
uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate);
uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode);
int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum);
void CAN_EnableInt(CAN_T  *tCAN, uint32_t u32Mask);
void CAN_DisableInt(CAN_T  *tCAN, uint32_t u32Mask);
int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID);
int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID);
int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum);

   

   

   







 





#line 32777 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"
 








 
#line 1 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"
 
 
 





 






 









#line 34 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"


  
  typedef unsigned int size_t;    








 
 

 
  typedef struct __va_list __va_list;





   




 




typedef struct __fpos_t_struct {
    unsigned __int64 __pos;
    



 
    struct {
        unsigned int __state1, __state2;
    } __mbstate;
} fpos_t;
   


 


   

 

typedef struct __FILE FILE;
   






 

extern FILE __stdin, __stdout, __stderr;
extern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;

#line 125 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"
    

    

    





     



   


 


   


 

   



 

   


 




   


 





    


 






extern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) FILE *tmpfile(void);
   




 
extern __declspec(__nothrow) char *tmpnam(char *  );
   











 

extern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) int fflush(FILE *  );
   







 
extern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
                           const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   








































 
extern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
                    const char * __restrict  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(2,3)));
   








 
extern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
                    char * __restrict  ) __attribute__((__nonnull__(1)));
   




 
extern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
                   char * __restrict  ,
                   int  , size_t  ) __attribute__((__nonnull__(1)));
   















 
#pragma __printf_args
extern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   


















 
#pragma __printf_args
extern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   




 
#pragma __printf_args
extern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






 
#pragma __printf_args
extern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

#pragma __printf_args
extern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   















 

#pragma __printf_args
extern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






























 
#pragma __scanf_args
extern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   






 
#pragma __scanf_args
extern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int sscanf(const char * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   








 
#pragma __scanf_args
extern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

 
extern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
                    const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int vsprintf(char * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 

extern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   







 

extern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   



 
extern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   










 
extern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   







 
extern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
   







 




    extern __declspec(__nothrow) int (getchar)(void);

   





 
extern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
   









 
extern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   





 




    extern __declspec(__nothrow) int (putchar)(int  );

   



 
extern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   






















 

extern __declspec(__nothrow) size_t fread(void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   











 

extern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
                    size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   











 

extern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   







 

extern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
   














 
extern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   










 
extern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
   











 
extern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
   





 

extern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
   




 

extern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) void perror(const char *  );
   









 

extern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
    
 

extern __declspec(__nothrow) void __use_no_semihosting_swi(void);
extern __declspec(__nothrow) void __use_no_semihosting(void);
    





 











#line 944 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"



 
#line 12 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"






 



 




 

















 
#line 56 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"












   



 
typedef struct SD_info_t {
    uint32_t    CardType;     
    uint32_t    RCA;          
    uint8_t IsCardInsert;     
} SD_INFO_T;

 
typedef struct disk_data_t {
    struct disk_data_t  *next;     

     
    unsigned int  totalSectorN;    
    unsigned int  diskSize;        
    int           sectorSize;      
    char          vendor[32];   
    char          product[32];  
    char          serial[32];   
} DISK_DATA_T;

   

extern SD_INFO_T SD0;
extern SD_INFO_T SD1;



 














 












 















 














 











 









 



void SD_Open(uint32_t u32CardDetSrc);
void SD_Probe(uint32_t u32CardNum);
uint32_t SD_Read(uint32_t u32CardNum, uint8_t *pu8BufAddr, uint32_t u32StartSec, uint32_t u32SecCount);
uint32_t SD_Write(uint32_t u32CardNum, uint8_t *pu8BufAddr, uint32_t u32StartSec, uint32_t u32SecCount);



   

   

   


 
#line 32778 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ps2.h"
 








 



 
 
 
#line 18 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ps2.h"









 



 




 

 
 
 








 










 









 









 
static __inline void PS2_CLEAR_TX_FIFO(void) 
{
    ((PS2_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0xA0000))->CTL |= (0x1ul << (8)); 
    ((PS2_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0xA0000))->CTL &= ~(0x1ul << (8));
}








 









 










 









 









 









 









 









 









 









 









 









 



 
 
 

void PS2_Open(void);
void PS2_Close(void);
uint8_t PS2_Read(void);
int32_t PS2_Write(uint32_t *pu32Buf, uint32_t u32ByteCount);
void PS2_EnableInt(uint32_t u32Mask);
void PS2_DisableInt(uint32_t u32Mask);


   

   

   







 

#line 32779 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"







 
#line 15 "..\\i2c_gpio.h"


























typedef void (*PFN_SWI2C_TIMEDELY)(uint32_t);
typedef struct {
    uint32_t u32SCKPortIndex;
    uint32_t u32SCKPinMask;
    uint32_t u32SDAPortIndex;
    uint32_t u32SDAPinMask;
} S_I2C_Channel;

typedef enum {
    eDRVGPIO_GPIOA = 0x00,
    eDRVGPIO_GPIOB = 0x40,
    eDRVGPIO_GPIOC = 0x80,
    eDRVGPIO_GPIOD = 0xC0,
    eDRVGPIO_GPIOE = 0x100,
    eDRVGPIO_GPIOF = 0x140,
    eDRVGPIO_GPIOG = 0x180,
    eDRVGPIO_GPIOH = 0x1C0,
    eDRVGPIO_GPIOI = 0x200,
    eDRVGPIO_GPIOJ = 0x240,
} E_DRVGPIO_PORT;
typedef enum {
    eDRVGPIO_PIN0 = (1),
    eDRVGPIO_PIN1 = (1<<1),
    eDRVGPIO_PIN2 = (1<<2),
    eDRVGPIO_PIN3 = (1<<3),
    eDRVGPIO_PIN4 = (1<<4),
    eDRVGPIO_PIN5 = (1<<5),
    eDRVGPIO_PIN6 = (1<<6),
    eDRVGPIO_PIN7 = (1<<7),
    eDRVGPIO_PIN8 = (1<<8),
    eDRVGPIO_PIN9 = (1<<9),
    eDRVGPIO_PIN10 = (1<<10),
    eDRVGPIO_PIN11 = (1<<11),
    eDRVGPIO_PIN12 = (1<<12),
    eDRVGPIO_PIN13 = (1<<13),
    eDRVGPIO_PIN14 = (1<<14),
    eDRVGPIO_PIN15 = (1<<15)
} E_DRVGPIO_BIT;




int SWI2C_Open(uint32_t u32SCKPortIndex,uint32_t u32SCKPinMask,uint32_t u32SDAPortIndex,
               uint32_t u32SDAPinMask,PFN_SWI2C_TIMEDELY pfntimedelay);
void SWI2C_Close(void);
void SWI2C_SendStart(void);
void SWI2C_SendStop(void);
int SWI2C_WriteByte(uint8_t u8Data, uint8_t u8AckType,uint8_t u8Length);
uint32_t SWI2C_ReadByte(uint8_t u8AckType,uint8_t u8Length);
uint8_t SWI2C_Slave_ReadByte(uint8_t u8AckType);
uint32_t SWI2C_GetVersion(void);


 
uint8_t SWI2C_Write_8bitSlaveAddr_8bitReg_8bitData(uint8_t uAddr, uint8_t uRegAddr, uint8_t uData);
uint8_t SWI2C_Read_8bitSlaveAddr_8bitReg_8bitData(uint8_t uAddr, uint8_t uRegAddr);


 
uint8_t SWI2C_Write_8bitSlaveAddr_16bitReg_8bitData(uint8_t uAddr, uint16_t uRegAddr, uint8_t uData);
uint8_t SWI2C_Read_8bitSlaveAddr_16bitReg_8bitData(uint8_t uAddr, uint16_t uRegAddr);
















#line 14 "..\\i2c_gpio.c"
#line 15 "..\\i2c_gpio.c"






static S_I2C_Channel s_sChannel;
static PFN_SWI2C_TIMEDELY pfntimedelay=0;

void _SWI2C_SDA_SETIN(uint32_t PortIndex, uint32_t PinMask)
{
    
    uint32_t u32pin = 0;
    uint32_t u32Idx = 1;
    uint32_t u32ModMask;
    for(u32pin=0; u32pin<16; u32pin=u32pin+1) {
        if(PinMask == u32Idx) {
            break;
        }
        u32Idx = u32Idx << 1;
    }
    u32ModMask = 3 <<(u32pin*2);
    *((volatile unsigned int *)(0x40004000+(PortIndex))) = (*((volatile unsigned int *)(0x40004000+(PortIndex))))&(~u32ModMask);
}
void _SWI2C_SCK_SETOUT(uint32_t PortIndex, uint32_t PinMask)
{
    uint32_t u32pin = 0;
    uint32_t u32Idx = 1;
    uint32_t u32ModMask, u32Out;
    for(u32pin=0; u32pin<16; u32pin=u32pin+1) {
        if(PinMask == u32Idx) {
            break;
        }
        u32Idx = u32Idx << 1;
    }
    u32ModMask = 3 <<(u32pin*2);
    u32Out = 1 <<(u32pin*2);
    *((volatile unsigned int *)(0x40004000+(PortIndex))) = ((*((volatile unsigned int *)(0x40004000+(PortIndex))))&(~u32ModMask))| u32Out;
}
void _SWI2C_SDA_SETOUT(uint32_t PortIndex, uint32_t PinMask)
{
    uint32_t u32pin = 0;
    uint32_t u32Idx = 1;
    uint32_t u32ModMask, u32Out;
    for(u32pin=0; u32pin<16; u32pin=u32pin+1) {
        if(PinMask == u32Idx) {
            break;
        }
        u32Idx = u32Idx << 1;
    }
    u32ModMask = 3 <<(u32pin*2);
    u32Out = 1 <<(u32pin*2);
    *((volatile unsigned int *)(0x40004000+(PortIndex))) = ((*((volatile unsigned int *)(0x40004000+(PortIndex))))&(~u32ModMask))|u32Out;
}
static void _SWI2C_Delay(
    uint32_t nCount
)
{
    volatile uint32_t i;
    if (pfntimedelay!=0) {
        pfntimedelay(nCount);
    } else {
        for(; nCount!=0; nCount--)
            for(i=0; i<200; i++);
    }
}
int
SWI2C_Open(
    uint32_t u32SCKPortIndex,
    uint32_t u32SCKPinMask,
    uint32_t u32SDAPortIndex,
    uint32_t u32SDAPinMask,
    PFN_SWI2C_TIMEDELY pfn_SWI2C_Delay
)
{
    
    s_sChannel.u32SCKPortIndex    = u32SCKPortIndex;
    s_sChannel.u32SCKPinMask     = u32SCKPinMask;
    s_sChannel.u32SDAPortIndex    = u32SDAPortIndex;
    s_sChannel.u32SDAPinMask     = u32SDAPinMask;

    
    
    
    
    
    
    

    _SWI2C_SCK_SETOUT(s_sChannel.u32SCKPortIndex, s_sChannel.u32SCKPinMask );
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask );
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;
    _SWI2C_Delay(5);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);
    _SWI2C_Delay(5);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;

    pfntimedelay=pfn_SWI2C_Delay;
    
    return 0;

}    

void SWI2C_Close(void)
{
    
    
}



void SWI2C_SendStart(void)
{
    
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;        
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;        
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);        
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);        
    _SWI2C_Delay(2);
}

void SWI2C_SendStop(void)
{





    
    _SWI2C_Delay(10);
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);        
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;        
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;        
    _SWI2C_Delay(2);
    

}



int
SWI2C_WriteByte(
    uint8_t u8Data,
    uint8_t u8AckType,
    uint8_t u8Length
)
{
    uint8_t   u8DataCount;
    uint32_t     i32HoldPinValue;
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    
    for ( u8DataCount=0; u8DataCount<u8Length; u8DataCount++ ) {
        if ( u8Data&0x80 )
            *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;
        else
            *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);
        _SWI2C_Delay(3);
        *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
        u8Data<<=1;
        _SWI2C_Delay(2);
        *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);
        _SWI2C_Delay(2);
    }

    
    if ( u8AckType == 0 )
        return 0;

    
    
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);
    _SWI2C_SDA_SETIN(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    _SWI2C_Delay(3);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
    _SWI2C_Delay(2);
    i32HoldPinValue = ((*((volatile unsigned int *)(0x40004010+(s_sChannel . u32SDAPortIndex))))&s_sChannel . u32SDAPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);
    _SWI2C_Delay(2);
    return (i32HoldPinValue == 0 ?0xFFFF0001: 0);
}



uint32_t
SWI2C_ReadByte(
    uint8_t u8AckType,
    uint8_t u8Length
)
{
    uint32_t   u32Data=0;
    uint8_t    u8DataCount;

    _SWI2C_SDA_SETIN(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    
    for ( u8DataCount=0; u8DataCount<u8Length; u8DataCount++ ) {
        u32Data = u32Data<<1;
        _SWI2C_Delay(3);
        *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
        if (((*((volatile unsigned int *)(0x40004010+(s_sChannel . u32SDAPortIndex))))&s_sChannel . u32SDAPinMask)==s_sChannel.u32SDAPinMask)
            u32Data = u32Data|0x01;
        _SWI2C_Delay(2);
        *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);
        _SWI2C_Delay(2);
    }
    
    if ( u8AckType == 0 )
        return u32Data;

    
    
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;
    _SWI2C_Delay(3);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))|s_sChannel . u32SCKPinMask;
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SCKPortIndex))))&(~s_sChannel . u32SCKPinMask);
    _SWI2C_Delay(2);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))&(~s_sChannel . u32SDAPinMask);
    return u32Data;
}



uint8_t
SWI2C_Slave_ReadByte(
    uint8_t u8AckType
)
{
    uint8_t u8Data, u8DataCount;
    u8Data = 0;
    
    for ( u8DataCount=0; u8DataCount<8;  ) {
        if (((*((volatile unsigned int *)(0x40004010+(s_sChannel . u32SCKPortIndex))))&s_sChannel . u32SCKPinMask)==0) {
            _SWI2C_Delay(3);

            if (((*((volatile unsigned int *)(0x40004010+(s_sChannel . u32SCKPortIndex))))&s_sChannel . u32SCKPinMask)==s_sChannel.u32SCKPinMask) {

                u8Data = u8Data<<1;
                if ( ((*((volatile unsigned int *)(0x40004010+(s_sChannel . u32SDAPortIndex))))&s_sChannel . u32SDAPinMask)==s_sChannel.u32SDAPinMask )
                    u8Data = u8Data|0x01;

                u8DataCount++;
            }
        }
    }
    
    if ( u8AckType == 0 )
        return u8Data;
    

    _SWI2C_Delay(2);
    _SWI2C_SDA_SETOUT(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    *((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))) = (*((volatile unsigned int *)(0x40004008+(s_sChannel . u32SDAPortIndex))))|s_sChannel . u32SDAPinMask;
    _SWI2C_Delay(7);
    _SWI2C_SDA_SETIN(s_sChannel.u32SDAPortIndex, s_sChannel.u32SDAPinMask);
    return u8Data;
}



static void Delay(uint32_t nCount)
{
    volatile uint32_t i;
    for(; nCount!=0; nCount--)
        for(i=0; i<100; i++);
}

 
uint8_t SWI2C_Write_8bitSlaveAddr_8bitReg_8bitData(uint8_t uAddr, uint8_t uRegAddr, uint8_t uData)
{
    
    volatile uint8_t u32Delay = 0x50;
    SWI2C_SendStart();
    while(u32Delay--);
    if ( (SWI2C_WriteByte(uAddr,1,8)==(0)) ||            
            (SWI2C_WriteByte(uRegAddr,1,8)==(0)) ||    
            (SWI2C_WriteByte(uData,1,8)==(0)) ) {      
        SWI2C_SendStop();
        return (0);
    }
    SWI2C_SendStop();

    if (uRegAddr==0x12 && (uData&0x80)!=0) {
        Delay(1000);
    }
    return (1);
}

 
uint8_t SWI2C_Read_8bitSlaveAddr_8bitReg_8bitData(uint8_t uAddr, uint8_t uRegAddr)
{
    uint8_t u8Data;

    
    SWI2C_SendStart();
    SWI2C_WriteByte(uAddr,1,8);        
    SWI2C_WriteByte(uRegAddr,1,8);    
    SWI2C_SendStop();

    
    SWI2C_SendStart();
    SWI2C_WriteByte(uAddr|0x01,1,8);        
    u8Data = SWI2C_ReadByte(1,8);        
    SWI2C_SendStop();

    return u8Data;
}

 
uint8_t SWI2C_Read_8bitSlaveAddr_16bitReg_8bitData(uint8_t uAddr, uint16_t uRegAddr)
{
    uint8_t u8Data;

    
    SWI2C_SendStart();
    SWI2C_WriteByte(uAddr,1,8);        
    SWI2C_WriteByte(uRegAddr>>8  ,1,8);    
    SWI2C_WriteByte(uRegAddr&0xFF,1,8);    
    

    
    SWI2C_SendStart();
    SWI2C_WriteByte(uAddr|0x01,1,8);        
    u8Data = SWI2C_ReadByte(1,8);        
    SWI2C_SendStop();

    return u8Data;
}

 
uint8_t SWI2C_Write_8bitSlaveAddr_16bitReg_8bitData(uint8_t uAddr, uint16_t uRegAddr, uint8_t uData)
{
    
    volatile uint8_t u32Delay = 0x50;
    SWI2C_SendStart();
    while(u32Delay--);
    if ( (SWI2C_WriteByte(uAddr        ,1,8)==(0)) ||  
            (SWI2C_WriteByte(uRegAddr>>8  ,1,8)==(0)) ||    
            (SWI2C_WriteByte(uRegAddr&0xff,1,8)==(0)) ||    
            (SWI2C_WriteByte(uData        ,1,8)==(0)) ) {      
        SWI2C_SendStop();
        return (0);
    }
    SWI2C_SendStop();

    if (uRegAddr==0x12 && (uData&0x80)!=0) {
        Delay(1000);
    }
    return (1);
}



































