#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"
 








 
#line 1 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"
 
 
 





 






 









#line 34 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"


  
  typedef unsigned int size_t;    








 
 

 
  typedef struct __va_list __va_list;





   




 




typedef struct __fpos_t_struct {
    unsigned __int64 __pos;
    



 
    struct {
        unsigned int __state1, __state2;
    } __mbstate;
} fpos_t;
   


 


   

 

typedef struct __FILE FILE;
   






 

extern FILE __stdin, __stdout, __stderr;
extern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;

#line 125 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"
    

    

    





     



   


 


   


 

   



 

   


 




   


 





    


 






extern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) FILE *tmpfile(void);
   




 
extern __declspec(__nothrow) char *tmpnam(char *  );
   











 

extern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) int fflush(FILE *  );
   







 
extern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
                           const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   








































 
extern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
                    const char * __restrict  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(2,3)));
   








 
extern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
                    char * __restrict  ) __attribute__((__nonnull__(1)));
   




 
extern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
                   char * __restrict  ,
                   int  , size_t  ) __attribute__((__nonnull__(1)));
   















 
#pragma __printf_args
extern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   


















 
#pragma __printf_args
extern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   




 
#pragma __printf_args
extern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






 
#pragma __printf_args
extern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

#pragma __printf_args
extern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   















 

#pragma __printf_args
extern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






























 
#pragma __scanf_args
extern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   






 
#pragma __scanf_args
extern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int sscanf(const char * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   








 
#pragma __scanf_args
extern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

 
extern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
                    const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int vsprintf(char * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 

extern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   







 

extern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   



 
extern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   










 
extern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   







 
extern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
   







 




    extern __declspec(__nothrow) int (getchar)(void);

   





 
extern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
   









 
extern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   





 




    extern __declspec(__nothrow) int (putchar)(int  );

   



 
extern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   






















 

extern __declspec(__nothrow) size_t fread(void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   











 

extern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
                    size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   











 

extern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   







 

extern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
   














 
extern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   










 
extern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
   











 
extern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
   





 

extern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
   




 

extern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) void perror(const char *  );
   









 

extern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
    
 

extern __declspec(__nothrow) void __use_no_semihosting_swi(void);
extern __declspec(__nothrow) void __use_no_semihosting(void);
    





 











#line 944 "E:\\Keil\\ARM\\RV31\\INC\\stdio.h"



 
#line 12 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"
#line 1 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
 
 
 
 




 








 











#line 37 "E:\\Keil\\ARM\\RV31\\INC\\string.h"


  
  typedef unsigned int size_t;








extern __declspec(__nothrow) void *memcpy(void * __restrict  ,
                    const void * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) void *memmove(void *  ,
                    const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
   







 
extern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   





 

extern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 






 

extern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
   





 
extern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   





 
extern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   







 

extern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
   













 


#line 184 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
extern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));

   





 

#line 200 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
extern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));

   




 

extern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   




 

#line 223 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
extern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));

   




 

#line 238 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
extern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));

   





 

extern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   



 

#line 261 "E:\\Keil\\ARM\\RV31\\INC\\string.h"
extern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));

   





 

extern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
extern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));

extern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));

   

































 

extern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) char *strerror(int  );
   





 
extern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
   



 

extern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   
















 

extern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






















 

extern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
    














































 







#line 493 "E:\\Keil\\ARM\\RV31\\INC\\string.h"



 
#line 13 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"
#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
 









 






































 

















































 







 
 
 



 



 
typedef enum IRQn {
     
    NonMaskableInt_IRQn           = -14,       
    MemoryManagement_IRQn         = -12,       
    BusFault_IRQn                 = -11,       
    UsageFault_IRQn               = -10,       
    SVCall_IRQn                   = -5,        
    DebugMonitor_IRQn             = -4,        
    PendSV_IRQn                   = -2,        
    SysTick_IRQn                  = -1,        

     

    BOD_IRQn                      = 0,         
    IRC_IRQn                      = 1,         
    PWRWU_IRQn                    = 2,         
    SRAMF_IRQn                    = 3,         
    CLKF_IRQn                     = 4,         
    RTC_IRQn                      = 6,         
    TAMPER_IRQn                   = 7,         
    EINT0_IRQn                    = 8,         
    EINT1_IRQn                    = 9,         
    EINT2_IRQn                    = 10,        
    EINT3_IRQn                    = 11,        
    EINT4_IRQn                    = 12,        
    EINT5_IRQn                    = 13,        
    EINT6_IRQn                    = 14,        
    EINT7_IRQn                    = 15,        
    GPA_IRQn                      = 16,        
    GPB_IRQn                      = 17,        
    GPC_IRQn                      = 18,        
    GPD_IRQn                      = 19,        
    GPE_IRQn                      = 20,        
    GPF_IRQn                      = 21,        
    GPG_IRQn                      = 22,        
    GPH_IRQn                      = 23,        
    GPI_IRQn                      = 24,        
    TMR0_IRQn                     = 32,        
    TMR1_IRQn                     = 33,        
    TMR2_IRQn                     = 34,        
    TMR3_IRQn                     = 35,        
    PDMA_IRQn                     = 40,        
    ADC_IRQn                      = 42,        
    WDT_IRQn                      = 46,        
    WWDT_IRQn                     = 47,        
    EADC0_IRQn                    = 48,        
    EADC1_IRQn                    = 49,        
    EADC2_IRQn                    = 50,        
    EADC3_IRQn                    = 51,        
    ACMP_IRQn                     = 56,        
    OPA0_IRQn                     = 60,        
    OPA1_IRQn                     = 61,        
    ICAP0_IRQn                    = 62,        
    ICAP1_IRQn                    = 63,        
    PWM0CH0_IRQn                  = 64,        
    PWM0CH1_IRQn                  = 65,        
    PWM0CH2_IRQn                  = 66,        
    PWM0CH3_IRQn                  = 67,        
    PWM0CH4_IRQn                  = 68,        
    PWM0CH5_IRQn                  = 69,        
    PWM0_BRK_IRQn                 = 70,        
    QEI0_IRQn                     = 71,        
    PWM1CH0_IRQn                  = 72,        
    PWM1CH1_IRQn                  = 73,        
    PWM1CH2_IRQn                  = 74,        
    PWM1CH3_IRQn                  = 75,        
    PWM1CHCH4_IRQn                = 76,        
    PWM1CH5_IRQn                  = 77,        
    PWM1_BRK_IRQn                 = 78,        
    QEI1_IRQn                     = 79,        
    EPWM0_IRQn                    = 80,        
    EPWM0BRK_IRQn                 = 81,        
    EPWM1_IRQn                    = 82,        
    EPWM1BRK_IRQn                 = 83,        
    USBD_IRQn                     = 88,        
    USBH_IRQn                     = 89,        
    USB_OTG_IRQn                  = 90,        
    EMAC_TX_IRQn                  = 92,        
    EMAC_RX_IRQn                  = 93,        
    SPI0_IRQn                     = 96,        
    SPI1_IRQn                     = 97,        
    SPI2_IRQn                     = 98,        
    SPI3_IRQn                     = 99,        
    UART0_IRQn                    = 104,       
    UART1_IRQn                    = 105,       
    UART2_IRQn                    = 106,       
    UART3_IRQn                    = 107,       
    UART4_IRQn                    = 108,       
    UART5_IRQn                    = 109,       
    I2C0_IRQn                     = 112,       
    I2C1_IRQn                     = 113,       
    I2C2_IRQn                     = 114,       
    I2C3_IRQn                     = 115,       
    I2C4_IRQn                     = 116,       
    SC0_IRQn                      = 120,       
    SC1_IRQn                      = 121,       
    SC2_IRQn                      = 122,       
    SC3_IRQn                      = 123,       
    SC4_IRQn                      = 124,       
    SC5_IRQn                      = 125,       
    CAN0_IRQn                     = 128,       
    CAN1_IRQn                     = 129,       
    I2S0_IRQn                     = 132,       
    I2S1_IRQn                     = 133,       
    SD_IRQn                       = 136,       
    PS2D_IRQn                     = 138,       
    CAP_IRQn                      = 139,       
    CRPT_IRQn                     = 140,       
    CRC_IRQn                      = 141,       
}
IRQn_Type;






 

 






   


#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
 




















 






















 




 


 

 













#line 89 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"


 
#line 103 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 152 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"
 
 





 









#line 25 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"







 

     

     
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

     
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

     

     
     
typedef   signed          char int_least8_t;
typedef   signed short     int int_least16_t;
typedef   signed           int int_least32_t;
typedef   signed       __int64 int_least64_t;

     
typedef unsigned          char uint_least8_t;
typedef unsigned short     int uint_least16_t;
typedef unsigned           int uint_least32_t;
typedef unsigned       __int64 uint_least64_t;

     

     
typedef   signed           int int_fast8_t;
typedef   signed           int int_fast16_t;
typedef   signed           int int_fast32_t;
typedef   signed       __int64 int_fast64_t;

     
typedef unsigned           int uint_fast8_t;
typedef unsigned           int uint_fast16_t;
typedef unsigned           int uint_fast32_t;
typedef unsigned       __int64 uint_fast64_t;

     
typedef   signed           int intptr_t;
typedef unsigned           int uintptr_t;

     
typedef   signed       __int64 intmax_t;
typedef unsigned       __int64 uintmax_t;




     

     





     





     





     

     





     





     





     

     





     





     





     

     


     


     


     

     


     


     


     

     



     



     


     
    
 



#line 196 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"

     







     










     











#line 260 "E:\\Keil\\ARM\\RV31\\INC\\stdint.h"



 


#line 154 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
 




















 





 



 


 









 







 







 






 








 







 







 









 









 
__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
{
  rev16 r0, r0
  bx lr
}








 
__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
{
  revsh r0, r0
  bx lr
}









 











 









 









 









 











 











 











 







 










 










 









 






#line 615 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"

   

#line 155 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"
 




















 





 



 


 





 
 






 
static __inline uint32_t __get_CONTROL(void)
{
  register uint32_t __regControl         __asm("control");
  return(__regControl);
}







 
static __inline void __set_CONTROL(uint32_t control)
{
  register uint32_t __regControl         __asm("control");
  __regControl = control;
}







 
static __inline uint32_t __get_IPSR(void)
{
  register uint32_t __regIPSR          __asm("ipsr");
  return(__regIPSR);
}







 
static __inline uint32_t __get_APSR(void)
{
  register uint32_t __regAPSR          __asm("apsr");
  return(__regAPSR);
}







 
static __inline uint32_t __get_xPSR(void)
{
  register uint32_t __regXPSR          __asm("xpsr");
  return(__regXPSR);
}







 
static __inline uint32_t __get_PSP(void)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  return(__regProcessStackPointer);
}







 
static __inline void __set_PSP(uint32_t topOfProcStack)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  __regProcessStackPointer = topOfProcStack;
}







 
static __inline uint32_t __get_MSP(void)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  return(__regMainStackPointer);
}







 
static __inline void __set_MSP(uint32_t topOfMainStack)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  __regMainStackPointer = topOfMainStack;
}







 
static __inline uint32_t __get_PRIMASK(void)
{
  register uint32_t __regPriMask         __asm("primask");
  return(__regPriMask);
}







 
static __inline void __set_PRIMASK(uint32_t priMask)
{
  register uint32_t __regPriMask         __asm("primask");
  __regPriMask = (priMask);
}








 







 








 
static __inline uint32_t  __get_BASEPRI(void)
{
  register uint32_t __regBasePri         __asm("basepri");
  return(__regBasePri);
}







 
static __inline void __set_BASEPRI(uint32_t basePri)
{
  register uint32_t __regBasePri         __asm("basepri");
  __regBasePri = (basePri & 0xff);
}







 
static __inline uint32_t __get_FAULTMASK(void)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  return(__regFaultMask);
}







 
static __inline void __set_FAULTMASK(uint32_t faultMask)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  __regFaultMask = (faultMask & (uint32_t)1);
}











 
static __inline uint32_t __get_FPSCR(void)
{

  register uint32_t __regfpscr         __asm("fpscr");
  return(__regfpscr);



}







 
static __inline void __set_FPSCR(uint32_t fpscr)
{

  register uint32_t __regfpscr         __asm("fpscr");
  __regfpscr = (fpscr);

}




#line 612 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"

 


#line 156 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"
 




















 











 


 



 


 

 
#line 106 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"








 



#line 641 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4_simd.h"

 




#line 157 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"








 
#line 192 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 






 
#line 208 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 













 


 





 


 
typedef union
{
  struct
  {



    uint32_t _reserved0:16;               
    uint32_t GE:4;                        
    uint32_t _reserved1:7;                

    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} APSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       
    uint32_t _reserved0:23;               
  } b;                                    
  uint32_t w;                             
} IPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       



    uint32_t _reserved0:7;                
    uint32_t GE:4;                        
    uint32_t _reserved1:4;                

    uint32_t T:1;                         
    uint32_t IT:2;                        
    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} xPSR_Type;



 
typedef union
{
  struct
  {
    uint32_t nPRIV:1;                     
    uint32_t SPSEL:1;                     
    uint32_t FPCA:1;                      
    uint32_t _reserved0:29;               
  } b;                                    
  uint32_t w;                             
} CONTROL_Type;

 






 


 
typedef struct
{
  volatile uint32_t ISER[8];                  
       uint32_t RESERVED0[24];
  volatile uint32_t ICER[8];                  
       uint32_t RSERVED1[24];
  volatile uint32_t ISPR[8];                  
       uint32_t RESERVED2[24];
  volatile uint32_t ICPR[8];                  
       uint32_t RESERVED3[24];
  volatile uint32_t IABR[8];                  
       uint32_t RESERVED4[56];
  volatile uint8_t  IP[240];                  
       uint32_t RESERVED5[644];
  volatile  uint32_t STIR;                     
}  NVIC_Type;

 



 






 


 
typedef struct
{
  volatile const  uint32_t CPUID;                    
  volatile uint32_t ICSR;                     
  volatile uint32_t VTOR;                     
  volatile uint32_t AIRCR;                    
  volatile uint32_t SCR;                      
  volatile uint32_t CCR;                      
  volatile uint8_t  SHP[12];                  
  volatile uint32_t SHCSR;                    
  volatile uint32_t CFSR;                     
  volatile uint32_t HFSR;                     
  volatile uint32_t DFSR;                     
  volatile uint32_t MMFAR;                    
  volatile uint32_t BFAR;                     
  volatile uint32_t AFSR;                     
  volatile const  uint32_t PFR[2];                   
  volatile const  uint32_t DFR;                      
  volatile const  uint32_t ADR;                      
  volatile const  uint32_t MMFR[4];                  
  volatile const  uint32_t ISAR[5];                  
       uint32_t RESERVED0[5];
  volatile uint32_t CPACR;                    
} SCB_Type;

 















 






























 



 





















 









 


















 










































 









 









 















 






 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile const  uint32_t ICTR;                     
  volatile uint32_t ACTLR;                    
} SCnSCB_Type;

 



 















 






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t LOAD;                     
  volatile uint32_t VAL;                      
  volatile const  uint32_t CALIB;                    
} SysTick_Type;

 












 



 



 









 






 


 
typedef struct
{
  volatile  union
  {
    volatile  uint8_t    u8;                   
    volatile  uint16_t   u16;                  
    volatile  uint32_t   u32;                  
  }  PORT [32];                           
       uint32_t RESERVED0[864];
  volatile uint32_t TER;                      
       uint32_t RESERVED1[15];
  volatile uint32_t TPR;                      
       uint32_t RESERVED2[15];
  volatile uint32_t TCR;                      
       uint32_t RESERVED3[29];                                  
  volatile  uint32_t IWR;                      
  volatile const  uint32_t IRR;                      
  volatile uint32_t IMCR;                     
       uint32_t RESERVED4[43];                                  
  volatile  uint32_t LAR;                      
  volatile const  uint32_t LSR;                      
       uint32_t RESERVED5[6];                                   
  volatile const  uint32_t PID4;                     
  volatile const  uint32_t PID5;                     
  volatile const  uint32_t PID6;                     
  volatile const  uint32_t PID7;                     
  volatile const  uint32_t PID0;                     
  volatile const  uint32_t PID1;                     
  volatile const  uint32_t PID2;                     
  volatile const  uint32_t PID3;                     
  volatile const  uint32_t CID0;                     
  volatile const  uint32_t CID1;                     
  volatile const  uint32_t CID2;                     
  volatile const  uint32_t CID3;                     
} ITM_Type;

 



 



























 



 



 



 









   






 


 
typedef struct
{
  volatile uint32_t CTRL;                     
  volatile uint32_t CYCCNT;                   
  volatile uint32_t CPICNT;                   
  volatile uint32_t EXCCNT;                   
  volatile uint32_t SLEEPCNT;                 
  volatile uint32_t LSUCNT;                   
  volatile uint32_t FOLDCNT;                  
  volatile const  uint32_t PCSR;                     
  volatile uint32_t COMP0;                    
  volatile uint32_t MASK0;                    
  volatile uint32_t FUNCTION0;                
       uint32_t RESERVED0[1];
  volatile uint32_t COMP1;                    
  volatile uint32_t MASK1;                    
  volatile uint32_t FUNCTION1;                
       uint32_t RESERVED1[1];
  volatile uint32_t COMP2;                    
  volatile uint32_t MASK2;                    
  volatile uint32_t FUNCTION2;                
       uint32_t RESERVED2[1];
  volatile uint32_t COMP3;                    
  volatile uint32_t MASK3;                    
  volatile uint32_t FUNCTION3;                
} DWT_Type;

 






















































 



 



 



 



 



 



 



























   






 


 
typedef struct
{
  volatile uint32_t SSPSR;                    
  volatile uint32_t CSPSR;                    
       uint32_t RESERVED0[2];
  volatile uint32_t ACPR;                     
       uint32_t RESERVED1[55];
  volatile uint32_t SPPR;                     
       uint32_t RESERVED2[131];
  volatile const  uint32_t FFSR;                     
  volatile uint32_t FFCR;                     
  volatile const  uint32_t FSCR;                     
       uint32_t RESERVED3[759];
  volatile const  uint32_t TRIGGER;                  
  volatile const  uint32_t FIFO0;                    
  volatile const  uint32_t ITATBCTR2;                
       uint32_t RESERVED4[1];
  volatile const  uint32_t ITATBCTR0;                
  volatile const  uint32_t FIFO1;                    
  volatile uint32_t ITCTRL;                   
       uint32_t RESERVED5[39];
  volatile uint32_t CLAIMSET;                 
  volatile uint32_t CLAIMCLR;                 
       uint32_t RESERVED7[8];
  volatile const  uint32_t DEVID;                    
  volatile const  uint32_t DEVTYPE;                  
} TPI_Type;

 



 



 












 






 



 





















 



 





















 



 



 


















 






   







 


 
typedef struct
{
  volatile const  uint32_t TYPE;                     
  volatile uint32_t CTRL;                     
  volatile uint32_t RNR;                      
  volatile uint32_t RBAR;                     
  volatile uint32_t RASR;                     
  volatile uint32_t RBAR_A1;                  
  volatile uint32_t RASR_A1;                  
  volatile uint32_t RBAR_A2;                  
  volatile uint32_t RASR_A2;                  
  volatile uint32_t RBAR_A3;                  
  volatile uint32_t RASR_A3;                  
} MPU_Type;

 









 









 



 









 






























 








 


 
typedef struct
{
       uint32_t RESERVED0[1];
  volatile uint32_t FPCCR;                    
  volatile uint32_t FPCAR;                    
  volatile uint32_t FPDSCR;                   
  volatile const  uint32_t MVFR0;                    
  volatile const  uint32_t MVFR1;                    
} FPU_Type;

 



























 



 












 
























 












 







 


 
typedef struct
{
  volatile uint32_t DHCSR;                    
  volatile  uint32_t DCRSR;                    
  volatile uint32_t DCRDR;                    
  volatile uint32_t DEMCR;                    
} CoreDebug_Type;

 




































 






 







































 






 

 
#line 1366 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1375 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cm4.h"











 










 

 



 




 










 
static __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);                

  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << 16) |
                (PriorityGroupTmp << 8));                                      
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
}







 
static __inline uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
}







 
static __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
}







 
static __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}











 
static __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}







 
static __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}







 
static __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
}










 
static __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
}










 
static __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
  else {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
}












 
static __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if(IRQn < 0) {
    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
  else {
    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
}













 
static __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}













 
static __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);           
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;

  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
}





 
static __inline void NVIC_SystemReset(void)
{
  __dsb(0xF);                                                     
 
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
                 (1UL << 2));                    
  __dsb(0xF);                                                      
  while(1);                                                     
}

 



 




 

















 
static __inline uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > (0xFFFFFFUL << 0))  return (1);             

  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
                   (1UL << 1)   |
                   (1UL << 0);                     
  return (0);                                                   
}



 



 




 

extern volatile int32_t ITM_RxBuffer;                     












 
static __inline uint32_t ITM_SendChar (uint32_t ch)
{
  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
  {
    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
  }
  return (ch);
}








 
static __inline int32_t ITM_ReceiveChar (void) {
  int32_t ch = -1;                            

  if (ITM_RxBuffer != 0x5AA55AA5) {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = 0x5AA55AA5;        
  }

  return (ch);
}








 
static __inline int32_t ITM_CheckChar (void) {

  if (ITM_RxBuffer == 0x5AA55AA5) {
    return (0);                                  
  } else {
    return (1);                                  
  }
}

 





#line 249 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\system_NUC472_442.h"
 








 







#line 19 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\system_NUC472_442.h"




 







extern uint32_t SystemCoreClock;      
extern uint32_t CyclesPerUs;          
extern uint32_t PllClock;             








 
extern void SystemInit (void);








 
extern void SystemCoreClockUpdate (void);






 
#line 250 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 251 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
 
 



 


#pragma anon_unions



 



 

typedef struct {


    





























 
    volatile uint32_t CTL[3];

    



























 
    volatile uint32_t STATUS;

    














 
    volatile uint32_t VREF;

} ACMP_T;




 














































   
   


 



 

typedef struct {


    



















 
    volatile const  uint32_t DAT[14];


    uint32_t RESERVE0[2];


    



































































 
    volatile uint32_t CTL;

    



















 
    volatile uint32_t CHEN;

    










































 
    volatile uint32_t CMP[2];

    





























 
    volatile uint32_t STATUS0;

    










 
    volatile const  uint32_t STATUS1;
    uint32_t RESERVE1[2];


    








 
    volatile const  uint32_t CURDAT;

} ADC_T;




 





































































































































































































































   
   


 



 

typedef struct {

    















 
    volatile uint32_t CREQ;

    



























































 
    volatile uint32_t CMASK;

    









 
    volatile uint32_t MASK1;

    

















 
    volatile uint32_t MASK2;

    









 
    volatile uint32_t ARB1;

    
























 
    volatile uint32_t ARB2;

    





















































 
    volatile uint32_t MCON;

    










 
    volatile uint32_t DAT_A1;

    










 
    volatile uint32_t DAT_A2;

    










 
    volatile uint32_t DAT_B1;

    










 
    volatile uint32_t DAT_B2;

    volatile const uint32_t RESERVE0[13];

} CAN_IF_T;

typedef struct {

    



























 
    volatile uint32_t   CON;

    




























 
    volatile uint32_t   STATUS;

    













 
    volatile uint32_t   ERR;

    




















 
    volatile uint32_t   BTIME;

    















 
    volatile uint32_t   IIDR;

    


























 
    volatile uint32_t   TEST;

    









 
    volatile uint32_t   BRPE;

    volatile const uint32_t    RESERVE0[1];

    volatile CAN_IF_T   IF[2];

    volatile const uint32_t    RESERVE1[8];

    










 
    volatile uint32_t   TXREQ1;

    










 
    volatile uint32_t   TXREQ2;

    volatile const uint32_t    RESERVE2[6];

    









 
    volatile uint32_t   NDAT1;

    









 
    volatile uint32_t   NDAT2;

    volatile const uint32_t    RESERVE3[6];

    









 
    volatile uint32_t   IPND1;

    









 
    volatile uint32_t   IPND2;

    volatile const uint32_t    RESERVE4[6];

    












 
    volatile uint32_t   MVLD1;

    











 
    volatile uint32_t   MVLD2;

    










 
    volatile uint32_t WU_EN;

    










 
    volatile uint32_t WU_STATUS;
} CAN_T;




 































































































































































































































   
   


 



 

typedef struct {


    



























 
    volatile uint32_t CTL;

    





































































 
    volatile uint32_t PAR;

    





























 
    volatile uint32_t INT;

    












 
    volatile uint32_t POSTERIZE;

    





















 
    volatile uint32_t MD;

    







 
    volatile uint32_t MDADDR;

    







 
    volatile uint32_t MDYADDR;

    








 
    volatile uint32_t SEPIA;

    








 
    volatile uint32_t CWSP;

    








 
    volatile uint32_t CWS;

    






















 
    volatile uint32_t PKTSL;

    






















 
    volatile uint32_t PLNSL;

    












 
    volatile uint32_t FRCTL;

    










 
    volatile uint32_t STRIDE;
    uint32_t RESERVE0[1];


    











 
    volatile uint32_t FIFOTH;

    








 
    volatile uint32_t CMPADDR;
    uint32_t RESERVE1[1];


    


















 
    volatile uint32_t PKTSM;

    


















 
    volatile uint32_t PLNSM;

    







 
    volatile const  uint32_t CURADDRP;

    







 
    volatile const  uint32_t CURADDRY;

    







 
    volatile const  uint32_t CURADDRU;

    







 
    volatile const  uint32_t CURVADDR;

    








 
    volatile uint32_t PKTBA0;

    








 
    volatile uint32_t PKTBA1;
    uint32_t RESERVE2[6];


    








 
    volatile uint32_t YBA;

    








 
    volatile uint32_t UBA;

    








 
    volatile uint32_t VBA;

} CAP_T;




 








































































































































































































































   
   


 



 

typedef struct {


    









 
    volatile uint32_t CNT;

    









 
    volatile uint32_t HOLD0;

    









 
    volatile uint32_t HOLD1;

    









 
    volatile uint32_t HOLD2;

    









 
    volatile uint32_t CNTCMP;

    

















































































 
    volatile uint32_t CTL0;

    













































 
    volatile uint32_t CTL1;

    































 
    volatile uint32_t STATUS;

} ECAP_T;




 










































































































   
   


 



 

typedef struct {


    























































 
    volatile uint32_t PWRCTL;

    







































 
    volatile uint32_t AHBCLK;

    
































































































 
    volatile uint32_t APBCLK0;

    





































































 
    volatile uint32_t APBCLK1;

    



























































 
    volatile uint32_t CLKSEL0;

    












































































 
    volatile uint32_t CLKSEL1;

    




























































 
    volatile uint32_t CLKSEL2;

    














































 
    volatile uint32_t CLKSEL3;

    
















 
    volatile uint32_t CLKDIV0;

    














 
    volatile uint32_t CLKDIV1;

    










 
    volatile uint32_t CLKDIV2;

    












 
    volatile uint32_t CLKDIV3;
    uint32_t RESERVE0[4];


    




























 
    volatile uint32_t PLLCTL;

    













 
    volatile uint32_t PLL2CTL;
    uint32_t RESERVE1[2];


    





































 
    volatile uint32_t STATUS;
    uint32_t RESERVE2[3];


    


















 
    volatile uint32_t CLKOCTL;
    uint32_t RESERVE3[3];


    
























 
    volatile uint32_t CLKDCTL;

} CLK_T;




 

















































































































































































































































































































































































































































   
   


 



 

typedef struct {


    








































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t DAT;

    








 
    volatile uint32_t SEED;

    








 
    volatile const  uint32_t CHECKSUM;

} CRC_T;




 


































   
   


 



 

typedef struct {
    

































 
    volatile uint32_t INTEN;

    






































 
    volatile uint32_t INTSTS;

    




















 
    volatile uint32_t PRNG_CTL;

    








 
    volatile  uint32_t PRNG_SEED;

    








 
    volatile const  uint32_t PRNG_KEY0;

    








 
    volatile const  uint32_t PRNG_KEY1;

    








 
    volatile const  uint32_t PRNG_KEY2;

    








 
    volatile const  uint32_t PRNG_KEY3;

    








 
    volatile const  uint32_t PRNG_KEY4;

    








 
    volatile const  uint32_t PRNG_KEY5;

    








 
    volatile const  uint32_t PRNG_KEY6;

    








 
    volatile const  uint32_t PRNG_KEY7;
    uint32_t RESERVE0[8];


    













 
    volatile const  uint32_t AES_FDBCK0;

    













 
    volatile const  uint32_t AES_FDBCK1;

    













 
    volatile const  uint32_t AES_FDBCK2;

    













 
    volatile const  uint32_t AES_FDBCK3;

    















 
    volatile const  uint32_t TDES_FDBCKH;

    















 
    volatile const  uint32_t TDES_FDBCKL;
    uint32_t RESERVE1[38];


    



































































 
    volatile uint32_t AES_CTL;

    








































 
    volatile const  uint32_t AES_STS;

    








 
    volatile uint32_t AES_DATIN;

    









 
    volatile const  uint32_t AES_DATOUT;

    














 
    volatile uint32_t AES0_KEY0;

    














 
    volatile uint32_t AES0_KEY1;

    














 
    volatile uint32_t AES0_KEY2;

    














 
    volatile uint32_t AES0_KEY3;

    














 
    volatile uint32_t AES0_KEY4;

    














 
    volatile uint32_t AES0_KEY5;

    














 
    volatile uint32_t AES0_KEY6;

    














 
    volatile uint32_t AES0_KEY7;

    











 
    volatile uint32_t AES0_IV0;

    











 
    volatile uint32_t AES0_IV1;

    











 
    volatile uint32_t AES0_IV2;

    











 
    volatile uint32_t AES0_IV3;

    


















 
    volatile uint32_t AES0_SADDR;

    


















 
    volatile uint32_t AES0_DADDR;

    

















 
    volatile uint32_t AES0_CNT;

    














 
    volatile uint32_t AES1_KEY0;

    














 
    volatile uint32_t AES1_KEY1;

    














 
    volatile uint32_t AES1_KEY2;

    














 
    volatile uint32_t AES1_KEY3;

    














 
    volatile uint32_t AES1_KEY4;

    














 
    volatile uint32_t AES1_KEY5;

    














 
    volatile uint32_t AES1_KEY6;

    














 
    volatile uint32_t AES1_KEY7;

    











 
    volatile uint32_t AES1_IV0;

    











 
    volatile uint32_t AES1_IV1;

    











 
    volatile uint32_t AES1_IV2;

    











 
    volatile uint32_t AES1_IV3;

    


















 
    volatile uint32_t AES1_SADDR;

    


















 
    volatile uint32_t AES1_DADDR;

    

















 
    volatile uint32_t AES1_CNT;

    














 
    volatile uint32_t AES2_KEY0;

    














 
    volatile uint32_t AES2_KEY1;

    














 
    volatile uint32_t AES2_KEY2;

    














 
    volatile uint32_t AES2_KEY3;

    














 
    volatile uint32_t AES2_KEY4;

    














 
    volatile uint32_t AES2_KEY5;

    














 
    volatile uint32_t AES2_KEY6;

    














 
    volatile uint32_t AES2_KEY7;

    











 
    volatile uint32_t AES2_IV0;

    











 
    volatile uint32_t AES2_IV1;

    











 
    volatile uint32_t AES2_IV2;

    











 
    volatile uint32_t AES2_IV3;

    


















 
    volatile uint32_t AES2_SADDR;

    


















 
    volatile uint32_t AES2_DADDR;

    

















 
    volatile uint32_t AES2_CNT;

    














 
    volatile uint32_t AES3_KEY0;

    














 
    volatile uint32_t AES3_KEY1;

    














 
    volatile uint32_t AES3_KEY2;

    














 
    volatile uint32_t AES3_KEY3;

    














 
    volatile uint32_t AES3_KEY4;

    














 
    volatile uint32_t AES3_KEY5;

    














 
    volatile uint32_t AES3_KEY6;

    














 
    volatile uint32_t AES3_KEY7;

    











 
    volatile uint32_t AES3_IV0;

    











 
    volatile uint32_t AES3_IV1;

    











 
    volatile uint32_t AES3_IV2;

    











 
    volatile uint32_t AES3_IV3;

    


















 
    volatile uint32_t AES3_SADDR;

    


















 
    volatile uint32_t AES3_DADDR;

    

















 
    volatile uint32_t AES3_CNT;

    


































































 
    volatile uint32_t TDES_CTL;

    




































 
    volatile const  uint32_t TDES_STS;

    











 
    volatile uint32_t TDES0_KEY1H;

    











 
    volatile uint32_t TDES0_KEY1L;

    











 
    volatile uint32_t TDES0_KEY2H;

    











 
    volatile uint32_t TDES0_KEY2L;

    











 
    volatile uint32_t TDES0_KEY3H;

    











 
    volatile uint32_t TDES0_KEY3L;

    









 
    volatile uint32_t TDES0_IVH;

    









 
    volatile uint32_t TDES0_IVL;

    


















 
    volatile uint32_t TDES0_SADDR;

    


















 
    volatile uint32_t TDES0_DADDR;

    














 
    volatile uint32_t TDES0_CNT;

    









 
    volatile uint32_t TDES_DATIN;

    









 
    volatile const  uint32_t TDES_DATOUT;
    uint32_t RESERVE2[3];


    











 
    volatile uint32_t TDES1_KEY1H;

    











 
    volatile uint32_t TDES1_KEY1L;

    











 
    volatile uint32_t TDES1_KEY2H;

    











 
    volatile uint32_t TDES1_KEY2L;

    











 
    volatile uint32_t TDES1_KEY3H;

    











 
    volatile uint32_t TDES1_KEY3L;

    









 
    volatile uint32_t TDES1_IVH;

    









 
    volatile uint32_t TDES1_IVL;

    


















 
    volatile uint32_t TDES1_SADDR;

    


















 
    volatile uint32_t TDES1_DADDR;

    














 
    volatile uint32_t TDES1_CNT;
    uint32_t RESERVE3[5];


    











 
    volatile uint32_t TDES2_KEY1H;

    











 
    volatile uint32_t TDES2_KEY1L;

    











 
    volatile uint32_t TDES2_KEY2H;

    











 
    volatile uint32_t TDES2_KEY2L;

    











 
    volatile uint32_t TDES2_KEY3H;

    











 
    volatile uint32_t TDES2_KEY3L;

    









 
    volatile uint32_t TDES2_IVH;

    









 
    volatile uint32_t TDES2_IVL;

    


















 
    volatile uint32_t TDES2_SADDR;

    


















 
    volatile uint32_t TDES2_DADDR;

    














 
    volatile uint32_t TDES2_CNT;
    uint32_t RESERVE4[5];


    











 
    volatile uint32_t TDES3_KEY1H;

    











 
    volatile uint32_t TDES3_KEY1L;

    











 
    volatile uint32_t TDES3_KEY2H;

    











 
    volatile uint32_t TDES3_KEY2L;

    











 
    volatile uint32_t TDES3_KEY3H;

    











 
    volatile uint32_t TDES3_KEY3L;

    









 
    volatile uint32_t TDES3_IVH;

    









 
    volatile uint32_t TDES3_IVL;

    


















 
    volatile uint32_t TDES3_SADDR;

    


















 
    volatile uint32_t TDES3_DADDR;

    














 
    volatile uint32_t TDES3_CNT;
    uint32_t RESERVE5[3];


    

































 
    volatile uint32_t SHA_CTL;

    


















 
    volatile const  uint32_t SHA_STS;

    










 
    volatile const  uint32_t SHA_DGST0;

    










 
    volatile const  uint32_t SHA_DGST1;

    










 
    volatile const  uint32_t SHA_DGST2;

    










 
    volatile const  uint32_t SHA_DGST3;

    










 
    volatile const  uint32_t SHA_DGST4;

    










 
    volatile const  uint32_t SHA_DGST5;

    










 
    volatile const  uint32_t SHA_DGST6;

    










 
    volatile const  uint32_t SHA_DGST7;
    uint32_t RESERVE6[8];


    













 
    volatile uint32_t SHA_KEYCNT;

    


















 
    volatile uint32_t SHA_SADDR;

    














 
    volatile uint32_t SHA_DMACNT;

    








 
    volatile uint32_t SHA_DATIN;

} CRPT_T;




 




















































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    

















 
    volatile const  uint32_t AD0DAT0;

    

















 
    volatile const  uint32_t AD0DAT1;

    

















 
    volatile const  uint32_t AD0DAT2;

    

















 
    volatile const  uint32_t AD0DAT3;

    

















 
    volatile const  uint32_t AD0DAT4;

    

















 
    volatile const  uint32_t AD0DAT5;

    

















 
    volatile const  uint32_t AD0DAT6;

    

















 
    volatile const  uint32_t AD0DAT7;

    

















 
    volatile const  uint32_t AD1DAT0;

    

















 
    volatile const  uint32_t AD1DAT1;

    

















 
    volatile const  uint32_t AD1DAT2;

    

















 
    volatile const  uint32_t AD1DAT3;

    

















 
    volatile const  uint32_t AD1DAT4;

    

















 
    volatile const  uint32_t AD1DAT5;

    

















 
    volatile const  uint32_t AD1DAT6;

    

















 
    volatile const  uint32_t AD1DAT7;

    



































 
    volatile uint32_t CTL;
    uint32_t RESERVE0[1];


    














 
    volatile  uint32_t SWTRG;

    
















 
    volatile const  uint32_t PENDSTS;

    






















 
    volatile uint32_t ADIFOV;

    


















 
    volatile uint32_t OVSTS;

    





















































 
    volatile uint32_t AD0SPCTL0;

    





















































 
    volatile uint32_t AD0SPCTL1;

    





















































 
    volatile uint32_t AD0SPCTL2;

    





















































 
    volatile uint32_t AD0SPCTL3;

    





































 
    volatile uint32_t AD0SPCTL4;

    





































 
    volatile uint32_t AD0SPCTL5;

    





































 
    volatile uint32_t AD0SPCTL6;

    





































 
    volatile uint32_t AD0SPCTL7;

    





















































 
    volatile uint32_t AD1SPCTL0;

    





















































 
    volatile uint32_t AD1SPCTL1;

    





















































 
    volatile uint32_t AD1SPCTL2;

    





















































 
    volatile uint32_t AD1SPCTL3;

    





































 
    volatile uint32_t AD1SPCTL4;

    





































 
    volatile uint32_t AD1SPCTL5;

    





































 
    volatile uint32_t AD1SPCTL6;

    





































 
    volatile uint32_t AD1SPCTL7;
    uint32_t RESERVE1[3];


    






































 
    volatile uint32_t SIMUSEL;

    

































 
    volatile uint32_t CMP0;

    

































 
    volatile uint32_t CMP1;

    


















 
    volatile const  uint32_t STATUS0;

    

































































































 
    volatile uint32_t STATUS1;

    












 
    volatile uint32_t EXTSMPT;
    uint32_t RESERVE2[17];


    












 
    volatile const  uint32_t AD0DDAT0;

    












 
    volatile const  uint32_t AD0DDAT1;

    












 
    volatile const  uint32_t AD0DDAT2;

    












 
    volatile const  uint32_t AD0DDAT3;
    uint32_t RESERVE3[4];


    












 
    volatile const  uint32_t AD1DDAT0;

    












 
    volatile const  uint32_t AD1DDAT1;

    












 
    volatile const  uint32_t AD1DDAT2;

    












 
    volatile const  uint32_t AD1DDAT3;

    






























 
    volatile uint32_t DBMEN;

    






















































 
    volatile uint32_t INTSRC0;

    






















































 
    volatile uint32_t INTSRC1;

    






















































 
    volatile uint32_t INTSRC2;

    






















































 
    volatile uint32_t INTSRC3;

    






































































































 
    volatile uint32_t AD0TRGEN0;

    






































































































 
    volatile uint32_t AD0TRGEN1;

    






































































































 
    volatile uint32_t AD0TRGEN2;

    






































































































 
    volatile uint32_t AD0TRGEN3;

    






































































































 
    volatile uint32_t AD1TRGEN0;

    






































































































 
    volatile uint32_t AD1TRGEN1;

    






































































































 
    volatile uint32_t AD1TRGEN2;

    






































































































 
    volatile uint32_t AD1TRGEN3;

} EADC_T;




 























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    
























 
    volatile uint32_t CTL;

    






































 
    volatile uint32_t TCTL[3];

    







 
    volatile uint32_t KEY0;

    







 
    volatile uint32_t KEY1;

    







 
    volatile uint32_t KEY2;

    







 
    volatile uint32_t KEY3;

} EBI_T;




 

















































   
   


 



 

typedef struct {


    
































 
    volatile uint32_t CAMCTL;

    












 
    volatile uint32_t CAMEN;

    














 
    volatile uint32_t CAM0M;

    













 
    volatile uint32_t CAM0L;

    














 
    volatile uint32_t CAM1M;

    













 
    volatile uint32_t CAM1L;

    














 
    volatile uint32_t CAM2M;

    













 
    volatile uint32_t CAM2L;

    














 
    volatile uint32_t CAM3M;

    













 
    volatile uint32_t CAM3L;

    














 
    volatile uint32_t CAM4M;

    













 
    volatile uint32_t CAM4L;

    














 
    volatile uint32_t CAM5M;

    













 
    volatile uint32_t CAM5L;

    














 
    volatile uint32_t CAM6M;

    













 
    volatile uint32_t CAM6L;

    














 
    volatile uint32_t CAM7M;

    













 
    volatile uint32_t CAM7L;

    














 
    volatile uint32_t CAM8M;

    













 
    volatile uint32_t CAM8L;

    














 
    volatile uint32_t CAM9M;

    













 
    volatile uint32_t CAM9L;

    














 
    volatile uint32_t CAM10M;

    













 
    volatile uint32_t CAM10L;

    














 
    volatile uint32_t CAM11M;

    













 
    volatile uint32_t CAM11L;

    














 
    volatile uint32_t CAM12M;

    













 
    volatile uint32_t CAM12L;

    














 
    volatile uint32_t CAM13M;

    













 
    volatile uint32_t CAM13L;

    














 
    volatile uint32_t CAM14M;

    













 
    volatile uint32_t CAM14L;

    










 
    volatile uint32_t CAM15MSB;

    









 
    volatile uint32_t CAM15LSB;

    












 
    volatile uint32_t TXDSA;

    












 
    volatile uint32_t RXDSA;

    








































































































 
    volatile uint32_t CTL;

    








 
    volatile uint32_t MIIMDAT;

    
































 
    volatile uint32_t MIIMCTL;

    



































 
    volatile uint32_t FIFOCTL;

    











 
    volatile  uint32_t TXST;

    











 
    volatile  uint32_t RXST;

    










 
    volatile uint32_t MRFL;

    


























































































































































 
    volatile uint32_t INTEN;

    














































































































































































 
    volatile uint32_t INTSTS;

    














































 
    volatile uint32_t GENSTS;

    












 
    volatile uint32_t MPCNT;

    









 
    volatile const  uint32_t RPCNT;
    uint32_t RESERVE0[2];


    










 
    volatile uint32_t FRSTS;

    









 
    volatile const  uint32_t CTXDSA;

    









 
    volatile const  uint32_t CTXBSA;

    









 
    volatile const  uint32_t CRXDSA;

    









 
    volatile const  uint32_t CRXBSA;
    uint32_t RESERVE1[9];


    





























 
    volatile uint32_t TSCTL;
    uint32_t RESERVE2[3];


    









 
    volatile const  uint32_t TSSEC;

    









 
    volatile const  uint32_t TSSUBSEC;

    









 
    volatile uint32_t TSINC;

    










 
    volatile uint32_t TSADDEND;

    










 
    volatile uint32_t UPDSEC;

    










 
    volatile uint32_t UPDSUBSEC;

    










 
    volatile uint32_t ALMSEC;

    










 
    volatile uint32_t ALMSUBSEC;

} EMAC_T;




 



























































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    



































































































 
    volatile uint32_t CTL;

    














































 
    volatile uint32_t STATUS;

    













 
    volatile uint32_t PERIOD;

    













 
    volatile uint32_t CMPDAT0;

    













 
    volatile uint32_t CMPDAT2;

    













 
    volatile uint32_t CMPDAT4;

    












 
    volatile uint32_t MSKEN;

    











 
    volatile uint32_t MSK;

    








 
    volatile uint32_t ASYMCMP0;

    








 
    volatile uint32_t ASYMCMP2;

    








 
    volatile uint32_t ASYMCMP4;

    



























 
    volatile uint32_t DTCTL;

    











 
    volatile uint32_t BRKOUT;

    











 
    volatile uint32_t NPCTL;

    












































































 
    volatile uint32_t ASYMCTL;

    









 
    volatile uint32_t PERIODCNT;

    
























 
    volatile uint32_t EINTCTL;

    












 
    volatile uint32_t OUTEN0;

} EPWM_T;




 



























































































































































































   
   


 



 

typedef struct {
    



































 
    volatile uint32_t ISPCTL;

    









 
    volatile uint32_t ISPADDR;

    









 
    volatile uint32_t ISPDAT;

    








 
    volatile uint32_t ISPCMD;

    












 
    volatile uint32_t ISPTRG;

    









 
    volatile const  uint32_t DFBA;

    


















 
    volatile uint32_t FTCTL;
    uint32_t RESERVE0[9];

    


























 
    volatile uint32_t ISPSTS;

    
















































































 
    volatile uint32_t FBWP;
    uint32_t RESERVE1[14];

    









 
    volatile uint32_t MPDAT0;

    








 
    volatile uint32_t MPDAT1;

    








 
    volatile uint32_t MPDAT2;

    








 
    volatile uint32_t MPDAT3;

    uint32_t RESERVE2[12];

    































 
    volatile uint32_t MPSTS;

    










 
    volatile uint32_t MPADDR;

} FMC_T;





 
























































































   
   


 



 

typedef struct {


    






















































































































































 
    volatile uint32_t MODE;

    






















































































 
    volatile uint32_t DINOFF;

    






































































 
    volatile uint32_t DOUT;

    






































































































 
    volatile uint32_t DATMSK;

    






















































 
    volatile const  uint32_t PIN;

    






















































































































 
    volatile uint32_t DBEN;

    






















































































































































































 
    volatile uint32_t INTTYPE;

    






































































































































































 
    volatile uint32_t INTEN;

    






















































































































 
    volatile uint32_t INTSRC;

    






































 
    volatile uint32_t SMTEN;

    






































 
    volatile uint32_t SLEWCTL;

} GPIO_T;


typedef struct {

    






























 
    volatile uint32_t DBCTL;

} GPIO_DB_T;




 










































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    




























 
    volatile uint32_t CTL;

    













 
    volatile uint32_t ADDR0;

    








 
    volatile uint32_t DAT;

    











 
    volatile const  uint32_t STATUS;

    









 
    volatile uint32_t CLKDIV;

    


















 
    volatile uint32_t TOCTL;

    













 
    volatile uint32_t ADDR1;

    













 
    volatile uint32_t ADDR2;

    













 
    volatile uint32_t ADDR3;

    












 
    volatile uint32_t ADDRMSK0;

    












 
    volatile uint32_t ADDRMSK1;

    












 
    volatile uint32_t ADDRMSK2;

    












 
    volatile uint32_t ADDRMSK3;
    uint32_t RESERVE0[2];


    









 
    volatile uint32_t WKCTL;

    










 
    volatile uint32_t WKSTS;

} I2C_T;




 















































































   
   


 



 

typedef struct {


    




































































































 
    volatile uint32_t CTL;

    


















 
    volatile uint32_t CLKDIV;

    







































 
    volatile uint32_t IEN;

    






























































































 
    volatile const  uint32_t STATUS;

    










 
    volatile  uint32_t TX;

    










 
    volatile const  uint32_t RX;

} I2S_T;




 























































































































































   
   


 



 

typedef struct {


    






























 
    volatile uint32_t CTL;

    


















 
    volatile uint32_t STATUS;

} OPA_T;




 































   
   


 



 

typedef struct {


    



























 
    volatile uint32_t CTL;

    






































 
    volatile uint32_t PHYCTL;

    















































 
    volatile uint32_t INTEN;

    




























































 
    volatile uint32_t INTSTS;

    

























 
    volatile const  uint32_t STATUS;

} OTG_T;




 











































































































































   
   


 



 

typedef struct {

    























































 
    volatile uint32_t CTL;

    










 
    volatile uint32_t ENDSA;

    










 
    volatile uint32_t ENDDA;

    











 
    volatile uint32_t NEXT;

} DSCT_T;

typedef struct {
    DSCT_T DSCT[16];
    uint32_t RESERVE0[192];

    













 
    volatile uint32_t CHCTL;

    















 
    volatile  uint32_t STOP;

    














 
    volatile  uint32_t SWREQ;

    













 
    volatile const  uint32_t TRGSTS;

    











 
    volatile uint32_t PRISET;

    











 
    volatile  uint32_t PRICLR;

    










 
    volatile uint32_t INTEN;

    



























 
    volatile uint32_t INTSTS;

    











 
    volatile uint32_t ABTSTS;

    











 
    volatile uint32_t TDSTS;

    











 
    volatile uint32_t SCATSTS;

    










 
    volatile const  uint32_t TACTSTS;
    uint32_t RESERVE1[3];


    











 
    volatile uint32_t SCATBA;

    












 
    volatile uint32_t TOC0_1;

    












 
    volatile uint32_t TOC2_3;

    












 
    volatile uint32_t TOC4_5;

    












 
    volatile uint32_t TOC6_7;

    












 
    volatile uint32_t TOC8_9;

    












 
    volatile uint32_t TOC10_11;

    












 
    volatile uint32_t TOC12_13;

    












 
    volatile uint32_t TOC14_15;
    uint32_t RESERVE2[8];


    




















































 
    volatile uint32_t REQSEL0_3;

    


























 
    volatile uint32_t REQSEL4_7;

    


























 
    volatile uint32_t REQSEL8_11;

    


























 
    volatile uint32_t REQSEL12_15;

} PDMA_T;




 


















































































































































































   
   


 



 

typedef struct {


    












































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t TXDAT0;

    









 
    volatile uint32_t TXDAT1;

    









 
    volatile uint32_t TXDAT2;

    









 
    volatile uint32_t TXDAT3;

    









 
    volatile const  uint32_t RXDAT;

    

















































































 
    volatile uint32_t STATUS;

    


















 
    volatile uint32_t INTSTS;

} PS2_T;




 












































































   
   


 



 

typedef struct {


    





















 
    volatile uint32_t CLKPSC;

    
























 
    volatile uint32_t CLKDIV;

    









































 
    volatile uint32_t CTL;

    










 
    volatile uint32_t CNTEN;

    
























 
    volatile uint32_t PERIOD[6];

    





















 
    volatile uint32_t CMPDAT[6];

    









 
    volatile const  uint32_t CNT[6];

    












 
    volatile uint32_t MSKEN;

    











 
    volatile uint32_t MSK;

    



































 
    volatile uint32_t DTCTL;

    



























 
    volatile uint32_t TRGADCTL;

    


























 
    volatile uint32_t TRGADCSTS;

    























































 
    volatile uint32_t BRKCTL;

    
















 
    volatile uint32_t INTCTL;

    

























 
    volatile uint32_t INTEN;

    







































 
    volatile uint32_t INTSTS;

    










 
    volatile uint32_t POEN;

    






















 
    volatile uint32_t CAPCTL;

    












 
    volatile uint32_t CAPINEN;

    












 
    volatile const  uint32_t CAPSTS;
    uint32_t RESERVE0[1];


    








 
    volatile const  uint32_t RCAPDAT0;

    








 
    volatile const  uint32_t FCAPDAT0;

    








 
    volatile const  uint32_t RCAPDAT1;

    








 
    volatile const  uint32_t FCAPDAT1;

    








 
    volatile const  uint32_t RCAPDAT2;

    








 
    volatile const  uint32_t FCAPDAT2;

    








 
    volatile const  uint32_t RCAPDAT3;

    








 
    volatile const  uint32_t FCAPDAT3;

    








 
    volatile const  uint32_t RCAPDAT4;

    








 
    volatile const  uint32_t FCAPDAT4;

    








 
    volatile const  uint32_t RCAPDAT5;

    








 
    volatile const  uint32_t FCAPDAT5;
    uint32_t RESERVE1[8];


    










 
    volatile const  uint32_t SBS[6];

} PWM_T;




 








































































































































































































































































































































   
   


 



 

typedef struct {


    














 
    volatile uint32_t CNT;

    








 
    volatile uint32_t CNTHOLD;

    








 
    volatile uint32_t CNTLATCH;

    









 
    volatile uint32_t CNTCMP;
    uint32_t RESERVE0[1];


    








 
    volatile uint32_t CNTMAX;

    




















































































 
    volatile uint32_t CTR;
    uint32_t RESERVE1[4];


    
































 
    volatile uint32_t STATUS;

} QEI_T;




 

































































































   
   


 



 

typedef struct {

    














 
    volatile uint32_t INIT;

    












 
    volatile  uint32_t RWEN;

    










 
    volatile uint32_t FREQADJ;

    












 
    volatile uint32_t TIME;

    












 
    volatile uint32_t CAL;

    










 
    volatile uint32_t CLKFMT;

    















 
    volatile uint32_t WEEKDAY;

    












 
    volatile uint32_t TALM;

    












 
    volatile uint32_t CALM;

    









 
    volatile const  uint32_t LEAPYEAR;

    












 
    volatile uint32_t INTEN;

    














 
    volatile uint32_t INTSTS;

    

















 
    volatile uint32_t TICK;
    uint32_t RESERVE0[2];


    
















 
    volatile uint32_t SPRCTL;

    










 
    volatile uint32_t SPR[24];
    uint32_t RESERVE1[28];


    






























 
    volatile uint32_t TAMPCTL;

    














 
    volatile uint32_t TAMPSTS;
    uint32_t RESERVE2[3];


    





















 
    volatile uint32_t TAMP0PCTL;

    





















 
    volatile uint32_t TAMP1PCTL;

    





















 
    volatile uint32_t LXTIPCTL;

    





















 
    volatile uint32_t LXTOPCTL;
    uint32_t RESERVE3[3];


    












 
    volatile uint32_t TAMSK;

    












 
    volatile uint32_t CAMSK;

} RTC_T;




 























































































































































































































































   
   


 



 

typedef struct {


    












 
    volatile uint32_t DAT;

    



























































































 
    volatile uint32_t CTL;

    































































































 
    volatile uint32_t ALTCTL;

    









 
    volatile uint32_t EGT;

    











 
    volatile uint32_t RXTOUT;

    















 
    volatile uint32_t ETUCTL;

    



















































 
    volatile uint32_t INTEN;

    
















































 
    volatile  uint32_t INTSTS;

    






















































































 
    volatile  uint32_t STATUS;

    


































































 
    volatile uint32_t PINCTL;

    











 
    volatile uint32_t TMRCTL0;

    











 
    volatile uint32_t TMRCTL1;

    











 
    volatile uint32_t TMRCTL2;

    


























 
    volatile uint32_t UARTCTL;

    








 
    volatile const  uint32_t TMRDAT0;

    










 
    volatile const  uint32_t TMRDAT1_2;

} SC_T;




 










































































































































































































































































































   
   


 



 

typedef struct {

    








 
    uint32_t FB[32];
    uint32_t RESERVE0[224];


    

























 
    volatile uint32_t DMACTL;
    uint32_t RESERVE1[1];


    













 
    volatile uint32_t DMASA;

    









 
    volatile const  uint32_t DMABCNT;

    












 
    volatile uint32_t DMAINTEN;

    















 
    volatile uint32_t DMAINTSTS;
    uint32_t RESERVE2[250];


    














 
    volatile uint32_t GCTL;

    









 
    volatile uint32_t GINTEN;

    












 
    volatile const  uint32_t GINTSTS;
    uint32_t RESERVE3[5];


    






























































 
    volatile uint32_t CTL;

    









 
    volatile uint32_t CMDARG;

    












































 
    volatile uint32_t INTEN;

    

















































































 
    volatile  uint32_t INTSTS;

    









 
    volatile const  uint32_t RESP0;

    









 
    volatile const  uint32_t RESP1;

    










 
    volatile uint32_t BLEN;

    












 
    volatile uint32_t TOUT;

} SDH_T;




 












































































































































































   
   


 



 

typedef struct {


    


















































































 
    volatile uint32_t CTL;

    












 
    volatile uint32_t CLKDIV;

    























































 
    volatile uint32_t SSCTL;

    





















 
    volatile uint32_t PDMACTL;

    










































 
    volatile uint32_t FIFOCTL;

    
































































































 
    volatile  uint32_t STATUS;
    uint32_t RESERVE0[2];


    












 
    volatile  uint32_t TX;
    uint32_t RESERVE1[3];


    











 
    volatile const  uint32_t RX;

} SPI_T;




 



























































































































































































   
   


 



 

typedef struct {


    









 
    volatile const  uint32_t PDID;

    


































 
    volatile uint32_t RSTSTS;

    











































































 
    volatile uint32_t IPRST0;

    

















































































 
    volatile uint32_t IPRST1;

    







































 
    volatile uint32_t IPRST2;
    uint32_t RESERVE0[1];


    






















































 
    volatile uint32_t BODCTL;

    












 
    volatile uint32_t TEMPCTL;

    











 
    volatile const  uint32_t VCID;

    













 
    volatile uint32_t PORCTL;

    



















 
    volatile uint32_t VREFCTL;

    















 
    volatile uint32_t USBPHY;

    














 
    volatile uint32_t GPA_MFPL;

    














 
    volatile uint32_t GPA_MFPH;

    














 
    volatile uint32_t GPB_MFPL;

    














 
    volatile uint32_t GPB_MFPH;

    














 
    volatile uint32_t GPC_MFPL;

    














 
    volatile uint32_t GPC_MFPH;

    














 
    volatile uint32_t GPD_MFPL;

    














 
    volatile uint32_t GPD_MFPH;

    














 
    volatile uint32_t GPE_MFPL;

    














 
    volatile uint32_t GPE_MFPH;

    














 
    volatile uint32_t GPF_MFPL;

    














 
    volatile uint32_t GPF_MFPH;

    














 
    volatile uint32_t GPG_MFPL;

    














 
    volatile uint32_t GPG_MFPH;

    














 
    volatile uint32_t GPH_MFPL;

    














 
    volatile uint32_t GPH_MFPH;

    














 
    volatile uint32_t GPI_MFPL;

    














 
    volatile uint32_t GPI_MFPH;
    uint32_t RESERVE1[18];


    









 
    volatile uint32_t SRAM_INTCTL;

    












 
    volatile uint32_t SRAM_STATUS;

    







 
    volatile const  uint32_t SRAM0_ERRADDR;

    








 
    volatile const  uint32_t SRAM1_ERRADDR;
    uint32_t RESERVE2[8];


    
































 
    volatile uint32_t IRCTCTL;

    
















 
    volatile uint32_t IRCTIEN;

    























 
    volatile uint32_t IRCTISTS;
    uint32_t RESERVE3[1];


    




























 
    volatile  uint32_t REGLCTL;

} SYS_T;




 






















































































































































































































































































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    




























































 
    volatile uint32_t CTL;

    













 
    volatile uint32_t CMP;

    
















 
    volatile uint32_t INTSTS;

    











 
    volatile const  uint32_t CNT;

    








 
    volatile const  uint32_t CAP;

    





































 
    volatile uint32_t EXTCTL;

    












 
    volatile uint32_t EINTSTS;

} TIMER_T;




 













































































   
   


 



 

typedef struct {


    













 
    volatile uint32_t DAT;

    


















































 
    volatile uint32_t INTEN;

    






























































 
    volatile uint32_t FIFO;

    



































 
    volatile uint32_t LINE;

    



















 
    volatile uint32_t MODEM;

    















 
    volatile uint32_t MODEMSTS;

    


























































 
    volatile uint32_t FIFOSTS;

    




































































































 
    volatile uint32_t INTSTS;

    















 
    volatile uint32_t TOUT;

    





















 
    volatile uint32_t BAUD;

    













 
    volatile uint32_t IRDA;

    






































 
    volatile uint32_t ALTCTL;

    












 
    volatile uint32_t FUNCSEL;

    












































































 
    volatile uint32_t LINCTL;

    













































 
    volatile uint32_t LINSTS;

    














 
    volatile uint32_t LINDEBUG;

    






 
    volatile uint32_t SCCTL;

    






 
    volatile uint32_t SCSTATUS;

} UART_T;




 











































































































































































































































































































































   
   


 



 

typedef struct {
    










 
    volatile const  uint32_t HcRev;

    



































 
    volatile uint32_t HcControl;

    


















 
    volatile uint32_t HcComSts;

    




















 
    volatile uint32_t HcIntSts;

    





























 
    volatile uint32_t HcIntEn;

    




























 
    volatile uint32_t HcIntDis;

    








 
    volatile uint32_t HcHCCA;

    








 
    volatile uint32_t HcPerCED;

    








 
    volatile uint32_t HcCtrHED;

    








 
    volatile uint32_t HcCtrCED;

    








 
    volatile uint32_t HcBlkHED;

    








 
    volatile uint32_t HcBlkCED;

    








 
    volatile uint32_t HcDoneH;

    













 
    volatile uint32_t HcFmIntv;

    












 
    volatile const  uint32_t HcFmRem;

    









 
    volatile const  uint32_t HcFNum;

    








 
    volatile uint32_t HcPerSt;

    










 
    volatile uint32_t HcLSTH;

    






































 
    volatile uint32_t HcRhDeA;

    














 
    volatile uint32_t HcRhDeB;

    






























 
    volatile uint32_t HcRhSts;

    





































































 
    volatile uint32_t HcRhPrt[2];

    uint32_t RESERVE0[105];


    










 
    volatile uint32_t MiscCtrl;

    



































 
    volatile uint32_t OpModEn;

} USBH_T;




 
































































































































































































































































   
   


 



 

typedef struct {


    
































































 
    volatile const  uint32_t GINTSTS;
    uint32_t RESERVE0[1];


    






























































 
    volatile uint32_t GINTEN;
    uint32_t RESERVE1[1];


    











































 
    volatile uint32_t BUSINTSTS;

    






































 
    volatile uint32_t BUSINTEN;

    
















 
    volatile uint32_t OPER;

    










 
    volatile const  uint32_t FRAMECNT;

    









 
    volatile uint32_t FADDR;

    
















 
    volatile uint32_t TEST;

    union {

        









 
        volatile uint32_t CEPDAT;
         
        volatile uint8_t  CEPDAT_BYTE;

    };

    
































 
    volatile uint32_t CEPCTL;

    













































 
    volatile uint32_t CEPINTEN;

    




























































 
    volatile uint32_t CEPINTSTS;

    










 
    volatile uint32_t CEPTXCNT;

    








 
    volatile const  uint32_t CEPRXCNT;

    








 
    volatile const  uint32_t CEPDATCNT;

    







































 
    volatile const  uint32_t SETUP1_0;

    












 
    volatile const  uint32_t SETUP3_2;

    












 
    volatile const  uint32_t SETUP5_4;

    












 
    volatile const  uint32_t SETUP7_6;

    








 
    volatile uint32_t CEPBUFSTART;

    








 
    volatile uint32_t CEPBUFEND;

    




















 
    volatile uint32_t DMACTL;

    








 
    volatile uint32_t DMACNT;

    union {

        









 
        volatile uint32_t EPADAT;
         
        volatile uint8_t  EPADAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPAINTSTS;

    


























































 
    volatile uint32_t EPAINTEN;

    










 
    volatile const  uint32_t EPADATCNT;

    














































 
    volatile uint32_t EPARSPCTL;

    








 
    volatile uint32_t EPAMPS;

    









 
    volatile uint32_t EPATXCNT;

    























 
    volatile uint32_t EPACFG;

    








 
    volatile uint32_t EPABUFSTART;

    








 
    volatile uint32_t EPABUFEND;

    union {

        









 
        volatile uint32_t EPBDAT;
         
        volatile uint8_t  EPBDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPBINTSTS;

    


























































 
    volatile uint32_t EPBINTEN;

    










 
    volatile const  uint32_t EPBDATCNT;

    














































 
    volatile uint32_t EPBRSPCTL;

    








 
    volatile uint32_t EPBMPS;

    









 
    volatile uint32_t EPBTXCNT;

    























 
    volatile uint32_t EPBCFG;

    








 
    volatile uint32_t EPBBUFSTART;

    








 
    volatile uint32_t EPBBUFEND;

    union {

        









 
        volatile uint32_t EPCDAT;
         
        volatile uint8_t  EPCDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPCINTSTS;

    


























































 
    volatile uint32_t EPCINTEN;

    










 
    volatile const  uint32_t EPCDATCNT;

    














































 
    volatile uint32_t EPCRSPCTL;

    








 
    volatile uint32_t EPCMPS;

    









 
    volatile uint32_t EPCTXCNT;

    























 
    volatile uint32_t EPCCFG;

    








 
    volatile uint32_t EPCBUFSTART;

    








 
    volatile uint32_t EPCBUFEND;

    union {

        









 
        volatile uint32_t EPDDAT;
         
        volatile uint8_t  EPDDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPDINTSTS;

    


























































 
    volatile uint32_t EPDINTEN;

    










 
    volatile const  uint32_t EPDDATCNT;

    














































 
    volatile uint32_t EPDRSPCTL;

    








 
    volatile uint32_t EPDMPS;

    









 
    volatile uint32_t EPDTXCNT;

    























 
    volatile uint32_t EPDCFG;

    








 
    volatile uint32_t EPDBUFSTART;

    








 
    volatile uint32_t EPDBUFEND;

    union {

        









 
        volatile uint32_t EPEDAT;
         
        volatile uint8_t  EPEDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPEINTSTS;

    


























































 
    volatile uint32_t EPEINTEN;

    










 
    volatile const  uint32_t EPEDATCNT;

    














































 
    volatile uint32_t EPERSPCTL;

    








 
    volatile uint32_t EPEMPS;

    









 
    volatile uint32_t EPETXCNT;

    























 
    volatile uint32_t EPECFG;

    








 
    volatile uint32_t EPEBUFSTART;

    








 
    volatile uint32_t EPEBUFEND;

    union {

        









 
        volatile uint32_t EPFDAT;
         
        volatile uint8_t  EPFDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPFINTSTS;

    


























































 
    volatile uint32_t EPFINTEN;

    










 
    volatile const  uint32_t EPFDATCNT;

    














































 
    volatile uint32_t EPFRSPCTL;

    








 
    volatile uint32_t EPFMPS;

    









 
    volatile uint32_t EPFTXCNT;

    























 
    volatile uint32_t EPFCFG;

    








 
    volatile uint32_t EPFBUFSTART;

    








 
    volatile uint32_t EPFBUFEND;

    union {

        









 
        volatile uint32_t EPGDAT;
         
        volatile uint8_t  EPGDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPGINTSTS;

    


























































 
    volatile uint32_t EPGINTEN;

    










 
    volatile const  uint32_t EPGDATCNT;

    














































 
    volatile uint32_t EPGRSPCTL;

    








 
    volatile uint32_t EPGMPS;

    









 
    volatile uint32_t EPGTXCNT;

    























 
    volatile uint32_t EPGCFG;

    








 
    volatile uint32_t EPGBUFSTART;

    








 
    volatile uint32_t EPGBUFEND;

    union {

        









 
        volatile uint32_t EPHDAT;
         
        volatile uint8_t  EPHDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPHINTSTS;

    


























































 
    volatile uint32_t EPHINTEN;

    










 
    volatile const  uint32_t EPHDATCNT;

    














































 
    volatile uint32_t EPHRSPCTL;

    








 
    volatile uint32_t EPHMPS;

    









 
    volatile uint32_t EPHTXCNT;

    























 
    volatile uint32_t EPHCFG;

    








 
    volatile uint32_t EPHBUFSTART;

    








 
    volatile uint32_t EPHBUFEND;

    union {

        









 
        volatile uint32_t EPIDAT;
         
        volatile uint8_t  EPIDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPIINTSTS;

    


























































 
    volatile uint32_t EPIINTEN;

    










 
    volatile const  uint32_t EPIDATCNT;

    














































 
    volatile uint32_t EPIRSPCTL;

    








 
    volatile uint32_t EPIMPS;

    









 
    volatile uint32_t EPITXCNT;

    























 
    volatile uint32_t EPICFG;

    








 
    volatile uint32_t EPIBUFSTART;

    








 
    volatile uint32_t EPIBUFEND;

    union {

        









 
        volatile uint32_t EPJDAT;
         
        volatile uint8_t  EPJDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPJINTSTS;

    


























































 
    volatile uint32_t EPJINTEN;

    










 
    volatile const  uint32_t EPJDATCNT;

    














































 
    volatile uint32_t EPJRSPCTL;

    








 
    volatile uint32_t EPJMPS;

    









 
    volatile uint32_t EPJTXCNT;

    























 
    volatile uint32_t EPJCFG;

    








 
    volatile uint32_t EPJBUFSTART;

    








 
    volatile uint32_t EPJBUFEND;

    union {

        









 
        volatile uint32_t EPKDAT;
         
        volatile uint8_t  EPKDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPKINTSTS;

    


























































 
    volatile uint32_t EPKINTEN;

    










 
    volatile const  uint32_t EPKDATCNT;

    














































 
    volatile uint32_t EPKRSPCTL;

    








 
    volatile uint32_t EPKMPS;

    









 
    volatile uint32_t EPKTXCNT;

    























 
    volatile uint32_t EPKCFG;

    








 
    volatile uint32_t EPKBUFSTART;

    








 
    volatile uint32_t EPKBUFEND;

    union {

        









 
        volatile uint32_t EPLDAT;
         
        volatile uint8_t  EPLDAT_BYTE;

    }; 

    

































































 
    volatile uint32_t EPLINTSTS;

    


























































 
    volatile uint32_t EPLINTEN;

    










 
    volatile const  uint32_t EPLDATCNT;

    














































 
    volatile uint32_t EPLRSPCTL;

    








 
    volatile uint32_t EPLMPS;

    









 
    volatile uint32_t EPLTXCNT;

    























 
    volatile uint32_t EPLCFG;

    








 
    volatile uint32_t EPLBUFSTART;

    








 
    volatile uint32_t EPLBUFEND;

    uint32_t RESERVE2[303];


    









 
    volatile uint32_t DMAADDR;

    


















 
    volatile uint32_t PHYCTL;

} USBD_T;




 



































































































































































































































































































































































































































































   
   


 



 

typedef struct {


    

























































 
    volatile uint32_t CTL;

    














 
    volatile uint32_t ALTCTL;

} WDT_T;




 


































   
   


 



 

typedef struct {


    










 
    volatile  uint32_t RLDCNT;

    








































 
    volatile uint32_t CTL;

    
















 
    volatile uint32_t STATUS;

    








 
    volatile const  uint32_t CNT;

} WWDT_T;




 




























   
   


#pragma no_anon_unions



   




 
 






 
#line 32418 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 32443 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 32468 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

   





 

#line 32500 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"







#line 32548 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
   




 

typedef volatile unsigned char  vu8;        
typedef volatile unsigned short vu16;       
typedef volatile unsigned long  vu32;       





 







 







 








 







 








 







 







 






 








 







 








 







 







 






 



   

 
 
 



 











 
#line 32734 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 










   


 
 
 
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
 








 











 



 



 


#line 41 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 
#line 94 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 
#line 109 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 


 
 
 
#line 127 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 








 
 
 






 















#line 171 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 179 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 188 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 198 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 208 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 216 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 224 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 232 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 240 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 248 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 256 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

















































#line 311 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









#line 327 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 337 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"






























#line 373 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 381 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

















#line 405 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"



#line 415 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 424 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 435 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 445 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 453 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 461 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"















#line 486 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

#line 493 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









#line 509 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 518 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 528 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 537 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 547 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 555 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 563 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 573 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 582 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 590 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 598 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 606 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
















































































#line 692 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 700 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"


#line 708 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"
















#line 731 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"









































































































































































































































































































































   



 

#line 1088 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sys.h"

void SYS_ClearResetSrc(uint32_t u32Src);
uint32_t SYS_GetBODStatus(void);
uint32_t SYS_GetResetSrc(void);
uint32_t SYS_IsRegLocked(void);
void SYS_LockReg(void);
void SYS_UnlockReg(void);
uint32_t  SYS_ReadPDID(void);
void SYS_ResetChip(void);
void SYS_ResetCPU(void);
void SYS_ResetModule(uint32_t u32ModuleIndex);
void SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
void SYS_DisableBOD(void);

   

   

   







 
#line 32753 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"
 








 











 



 




 






 
 
 










#line 62 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"







 
 
 




 
 
 
#line 85 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

























 
 
 





















#line 140 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 147 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 154 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 161 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"














 
 
 




































 
 
 








































 
 
 






 
 
 





 
 
 



 
 
 





 
 
 
#line 300 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"
 
 
 
#line 314 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 345 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 368 "..\\..\\..\\..\\Library\\StdDriver\\inc\\clk.h"

   




 

void CLK_DisableCKO(void);
void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
void CLK_PowerDown(void);
void CLK_Idle(void);
uint32_t CLK_GetHXTFreq(void);
uint32_t CLK_GetLXTFreq(void);
uint32_t CLK_GetHCLKFreq(void);
uint32_t CLK_GetPCLKFreq(void);
uint32_t CLK_GetCPUFreq(void);
uint32_t CLK_GetPLLClockFreq(void);
uint32_t CLK_SetCoreClock(uint32_t u32Hclk);
void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
void CLK_EnableXtalRC(uint32_t u32ClkMask);
void CLK_DisableXtalRC(uint32_t u32ClkMask);
void CLK_EnableModuleClock(uint32_t u32ModuleIdx);
void CLK_DisableModuleClock(uint32_t u32ModuleIdx);
uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
void CLK_DisablePLL(void);
void CLK_SysTickDelay(uint32_t us);
uint32_t CLK_WaitClockReady(uint32_t u32ClkMask);

   

   

   







 
#line 32754 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"
 








 











 



 



 

 
 
 
#line 85 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"


   




 












































 
#line 146 "..\\..\\..\\..\\Library\\StdDriver\\inc\\acmp.h"







 








 








 








 









 








 








 








 








 














 








































 






 






 








 








 



void ACMP_Open(ACMP_T *acmp, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
void ACMP_Close(ACMP_T *acmp, uint32_t u32ChNum);

   

   

   







 
#line 32756 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"
 








 











 



 



 

#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"

   




 







 











 











 











 










 










 







 







 
















 
#line 179 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"





 
















 
#line 211 "..\\..\\..\\..\\Library\\StdDriver\\inc\\adc.h"





 








 







 







 










 







 







 







 


void ADC_Open(ADC_T *adc,
              uint32_t u32InputMode,
              uint32_t u32OpMode,
              uint32_t u32ChMask);
void ADC_Close(ADC_T *adc);
void ADC_EnableHWTrigger(ADC_T *adc,
                         uint32_t u32Source,
                         uint32_t u32Param);
void ADC_DisableHWTrigger(ADC_T *adc);
void ADC_SetExtraSampleTime(ADC_T *adc,
                            uint32_t u32ChNum,
                            uint32_t u32SampleTime);
void ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
void ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);



   

   

   







 
#line 32757 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"
 









 










 



 



 

 
 
 
#line 42 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"

 
 
 


                                                                       





















#line 76 "..\\..\\..\\..\\Library\\StdDriver\\inc\\cap.h"

 
 
 






static uint32_t u32EscapeFrame = 0;
 
 
 





   





 








 















 









 


void CAP_Open(uint32_t u32InFormat, uint32_t u32OutFormet);
void CAP_SetCroppingWindow(uint32_t u32VStart,uint32_t u32HStart, uint32_t u32Height, uint32_t u32Width);
void CAP_SetPacketBuf(uint32_t  u32Address );
void CAP_SetPlanarBuf(uint32_t u32YAddr, uint32_t u32UAddr, uint32_t u32VAddr);
void CAP_Close(void);
void CAP_EnableInt(uint32_t u32IntMask);
void CAP_DisableInt(uint32_t u32IntMask);
void CAP_Start(void);
void CAP_Stop(uint32_t u32FrameComplete);
void CAP_SetPacketScaling(uint32_t u32VNumerator, uint32_t u32VDenominator, uint32_t u32HNumerator, uint32_t u32HDenominator);
void CAP_SetPlanarScaling(uint32_t u32VNumerator, uint32_t u32VDenominator, uint32_t u32HNumerator, uint32_t u32HDenominator);
void CAP_SetPacketStride(uint32_t u32Stride );
void CAP_SetPlanarStride(uint32_t u32Stride );
void CAP_EnableMotionDet(uint32_t u32Freq, uint32_t u32BlockSize, uint32_t u32Format, uint32_t u32Threshold,  uint32_t u32YDetAddr, uint32_t u32DetAddr);
void CAP_DisableMotionDet(void);

   



   

   







 
#line 32758 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"
 








 










 



 




 













#line 52 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"












#line 72 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"














   




 

 
 
 

#line 117 "..\\..\\..\\..\\Library\\StdDriver\\inc\\crypto.h"

 
 
 

void PRNG_Open(uint32_t u32KeySize, uint32_t u32SeedReload, uint32_t u32Seed);
void PRNG_Start(void);
void PRNG_Read(uint32_t u32RandKey[]);
void AES_Open(uint32_t u32Channel, uint32_t u32EncDec, uint32_t u32OpMode, uint32_t u32KeySize, uint32_t u32SwapType);
void AES_Start(int32_t u32Channel, uint32_t u32DMAMode);
void AES_SetKey(uint32_t u32Channel, uint32_t au32Keys[], uint32_t u32KeySize);
void AES_SetInitVect(uint32_t u32Channel, uint32_t au32IV[]);
void AES_SetDMATransfer(uint32_t u32Channel, uint32_t u32SrcAddr, uint32_t u32DstAddr, uint32_t u32TransCnt);
void TDES_Open(uint32_t u32Channel, uint32_t u32EncDec, uint32_t u32OpMode, uint32_t u32SwapType);
void TDES_Start(int32_t u32Channel, uint32_t u32DMAMode);
void TDES_SetKey(uint32_t u32Channel, uint8_t au8Keys[3][8]);
void TDES_SetInitVect(uint32_t u32Channel, uint32_t u32IVH, uint32_t u32IVL);
void TDES_SetDMATransfer(uint32_t u32Channel, uint32_t u32SrcAddr, uint32_t u32DstAddr, uint32_t u32TransCnt);
void SHA_Open(uint32_t u32OpMode, uint32_t u32SwapType);
void SHA_Start(uint32_t u32DMAMode);
void SHA_SetDMATransfer(uint32_t u32SrcAddr, uint32_t u32TransCnt);
void SHA_Read(uint32_t u32Digest[]);


   

   

   







 

#line 32759 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"
 








 











 



 



 


 
 
 




 
 
 




 
 
 





 
 
 



#line 69 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"

 
 
 
#line 99 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pdma.h"

   



 










 











 











 











 











 











 











 











 











 












 












 












 












 











 




void PDMA_Open(uint32_t u32Mask);
void PDMA_Close(void);
void PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
void PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
void PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
void PDMA_SetBurstType(uint32_t u32Ch, uint32_t u32BurstType, uint32_t u32BurstSize);
void PDMA_SetTimeOut(uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
void PDMA_Trigger(uint32_t u32Ch);
void PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
void PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);



   

   

   







 
#line 32760 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"
 








 











 



 



 

 



#line 42 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 53 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

 



#line 75 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"


 





 



 



 



 
#line 102 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

#line 110 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ebi.h"

   




 
void EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
void EBI_Close(uint32_t u32Bank);
void EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
void EBI_EnableCrypto(uint32_t u32Bank, uint32_t *u32Key);
void EBI_DisbleCrypto(uint32_t u32Bank);


   

   

   







 
#line 32761 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\emac.h"
 








 











 



 



 







   




 







 








 







 








 







 








 









 







 







 







 







 









 







 



void EMAC_Open(uint8_t *pu8MacAddr);
void EMAC_Close(void);
void EMAC_SetMacAddr(uint8_t *pu8MacAddr);
void EMAC_EnableCamEntry(uint32_t u32Entry, uint8_t *pu8MacAddr);
void EMAC_DisableCamEntry(uint32_t u32Entry);

uint32_t EMAC_RecvPkt(uint8_t *pu8Data, uint32_t *pu32Size);
uint32_t EMAC_RecvPktTS(uint8_t *pu8Data, uint32_t *pu32Size, uint32_t *pu32Sec, uint32_t *pu32Nsec);
void EMAC_RecvPktDone(void);

uint32_t EMAC_SendPkt(uint8_t *pu8Data, uint32_t u32Size);
uint32_t EMAC_SendPktDone(void);
uint32_t EMAC_SendPktDoneTS(uint32_t *pu32Sec, uint32_t *pu32Nsec);

void EMAC_EnableTS(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_DisableTS(void);
void EMAC_GetTime(uint32_t *pu32Sec, uint32_t *pu32Nsec);
void EMAC_SetTime(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_UpdateTime(uint32_t u32Neg, uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_EnableAlarm(uint32_t u32Sec, uint32_t u32Nsec);
void EMAC_DisableAlarm(void);



   

   

   







 
#line 32762 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"
 









 










 



 




 


 
 
 









 
 
 
#line 59 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"





   




 

 
 
 

#line 87 "..\\..\\..\\..\\Library\\StdDriver\\inc\\fmc.h"

 
 
 

extern void FMC_SetBootSource(int32_t i32BootSrc);
extern void FMC_Close(void);
extern void FMC_DisableAPUpdate(void);
extern void FMC_DisableConfigUpdate(void);
extern void FMC_DisableLDUpdate(void);
extern void FMC_EnableAPUpdate(void);
extern void FMC_EnableConfigUpdate(void);
extern void FMC_EnableLDUpdate(void);
extern int32_t FMC_Erase(uint32_t u32PageAddr);
extern int32_t FMC_GetBootSource(void);
extern void FMC_Open(void);
extern uint32_t FMC_Read(uint32_t u32Addr);
extern void FMC_Read_64(uint32_t u32Addr, uint32_t *u32Data0, uint32_t *u32Data1);
extern uint32_t FMC_ReadCID(void);
extern uint32_t FMC_ReadDID(void);
extern uint32_t FMC_ReadPID(void);
extern uint32_t FMC_ReadUCID(uint32_t u32Index);
extern uint32_t FMC_ReadUID(uint32_t u32Index);
extern uint32_t FMC_ReadDataFlashBaseAddr(void);
extern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
extern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
extern void FMC_Write_64(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1);
extern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
extern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
extern uint32_t FMC_CRC8(uint32_t au32Data[], int i32Count);


   

   

   







 
#line 32763 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"
 








 











 



 



 


 
 
 





 
 
 






 
 
 



 
 
 






#line 81 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"














 
#line 113 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 130 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 147 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 164 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 181 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 198 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 215 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 232 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

#line 249 "..\\..\\..\\..\\Library\\StdDriver\\inc\\gpio.h"

   



 










 











 











 











 











 











 











 












 



















 










 











 











 













 












 














 












 













 












 



void GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
void GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
void GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);



   

   

   







 
#line 32764 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2c.h"
 








 











 



 



 









   




 







 







 







 







 







 








 







 









 









 


uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
void I2C_Close(I2C_T *i2c);
void I2C_ClearTimeoutFlag(I2C_T *i2c);
void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
void I2C_DisableInt(I2C_T *i2c);
void I2C_EnableInt(I2C_T *i2c);
uint32_t I2C_GetBusClockFreq(I2C_T *i2c);
uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
uint32_t I2C_GetIntFlag(I2C_T *i2c);
uint32_t I2C_GetStatus(I2C_T *i2c);
uint32_t I2C_GetData(I2C_T *i2c);
void I2C_SetData(I2C_T *i2c, uint8_t u8Data);
void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
void I2C_DisableTimeout(I2C_T *i2c);
void I2C_EnableWakeup(I2C_T *i2c);
void I2C_DisableWakeup(I2C_T *i2c);

   

   

   







 
#line 32765 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pwm.h"
 








 











 



 



 
#line 68 "..\\..\\..\\..\\Library\\StdDriver\\inc\\pwm.h"

   




 






 







 







 







 







 







 









 








 








 










 











 















 











 











 












 




uint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
                                 uint32_t u32ChannelNum,
                                 uint32_t u32Frequency,
                                 uint32_t u32DutyCycle);
uint32_t PWM_ConfigCaptureChannel (PWM_T *pwm,
                                   uint32_t u32ChannelNum,
                                   uint32_t u32UnitTimeNsec,
                                   uint32_t u32CaptureEdge);
void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableFaultBrake(PWM_T *pwm,
                          uint32_t u32ChannelMask,
                          uint32_t u32LevelMask,
                          uint32_t u32BrakeSource);
void PWM_ClearFaultBrakeFlag(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);



   

   

   







 
#line 32766 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"
 








 












 



 




 
















#line 57 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"

#line 65 "..\\..\\..\\..\\Library\\StdDriver\\inc\\rtc.h"




   




 



 
typedef struct {
    uint32_t u32Year;           
    uint32_t u32Month;          
    uint32_t u32Day;            
    uint32_t u32DayOfWeek;      
    uint32_t u32Hour;           
    uint32_t u32Minute;         
    uint32_t u32Second;         
    uint32_t u32TimeScale;      
    uint32_t u32AmPm;           
} S_RTC_TIME_DATA_T;

   







 









 










 










 









 









 









 









 









 









 




void RTC_Open(S_RTC_TIME_DATA_T *sPt);
void RTC_Close(void);
void RTC_32KCalibration(int32_t i32FrequencyX100);
void RTC_SetTickPeriod(uint32_t u32TickSelection);
void RTC_EnableInt(uint32_t u32IntFlagMask);
void RTC_DisableInt(uint32_t u32IntFlagMask);
uint32_t RTC_GetDayOfWeek(void);
void RTC_DisableTamperDetection(uint32_t u32PinNumber);
void RTC_EnableTamperDetection(uint32_t u32PinNumber, uint32_t u32PinCondition, uint32_t u32IntFlag, uint32_t u32ClearFlag, uint32_t u32DestroyEn);
void RTC_EnableSpareAccess(void);
void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);



   


   

   









 



#line 32767 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"
 








 











 



 



 
#line 37 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"

#line 48 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"


   




 


















 



















 








 
#line 112 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"








 
#line 129 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 145 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 161 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sc.h"






 








 









 







 
static __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
{
    while(sc->CTL & (0x1ul << (30)));
    if(u32Count == 0) {       
        sc->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));
    } else {
        sc->CTL = (sc->CTL & ~(0x7ul << (20))) | ((u32Count - 1) << (20)) | (0x1ul << (23));
    }
}






 
static __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
{
    while(sc->CTL & (0x1ul << (30)));
    if(u32Count == 0) {       
        sc->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));
    } else {
        sc->CTL = (sc->CTL & ~(0x7ul << (16))) | ((u32Count - 1) << (16)) | (0x1ul << (19));
    }
}


uint32_t SC_IsCardInserted(SC_T *sc);
void SC_ClearFIFO(SC_T *sc);
void SC_Close(SC_T *sc);
void SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
void SC_ResetReader(SC_T *sc);
void SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
void SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
void SC_StopAllTimer(SC_T *sc);
void SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
void SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);


   

   

   







 
#line 32768 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\scuart.h"
 








 











 



 



 













   




 

 






 









 









 








 









 









 



 






 









 










 










 









 


 











 












 














 











 










 











 


void SCUART_Close(SC_T* sc);
uint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
uint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
uint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
void SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
void SCUART_Write(SC_T* sc,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);

   

   

   







 
#line 32769 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\spi.h"
 








 











 



 



 














#line 56 "..\\..\\..\\..\\Library\\StdDriver\\inc\\spi.h"


   




 








 







 







 







 







 







 







 








 








 







 









 









 









 







 








 







 
static __inline void SPI_SET_SS0_HIGH(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x1);
}






 
static __inline void SPI_SET_SS0_LOW(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL &= ~(0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x1);
}






 
static __inline void SPI_SET_SS1_HIGH(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x2);
}






 
static __inline void SPI_SET_SS1_LOW(SPI_T *spi)
{
    spi->SSCTL &= ~(0x1ul << (3));
    spi->SSCTL |= (0x1ul << (2));
    spi->SSCTL = (spi->SSCTL & ~(0x3ul << (0))) | (0x2);
}







 








 









 








 








 









 
static __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
{
    if(u32Width == 32)
        u32Width = 0;

    spi->CTL = (spi->CTL & ~(0x1ful << (8))) | (u32Width << (8));
}








 







 







 







 







 







 







 







 







 







 







 







 







 







 







 








 








 


uint32_t SPI_Open(SPI_T *spi,uint32_t u32MasterSlave, uint32_t u32SPIMode,  uint32_t u32DataWidth, uint32_t u32BusClock);
void SPI_Close(SPI_T *spi);
void SPI_ClearRxFIFO(SPI_T *spi);
void SPI_ClearTxFIFO(SPI_T *spi);
void SPI_DisableAutoSS(SPI_T *spi);
void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
void SPI_SetFIFOThreshold(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
uint32_t SPI_GetBusClock(SPI_T *spi);
void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);


   

   

   







 
#line 32770 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\timer.h"
 








 











 



 



 

#line 46 "..\\..\\..\\..\\Library\\StdDriver\\inc\\timer.h"

   




 







 









 








 










 







 
static __inline void TIMER_Start(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (30));
}





 
static __inline void TIMER_Stop(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (30));
}






 
static __inline void TIMER_EnableWakeup(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (23));
}





 
static __inline void TIMER_DisableWakeup(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (23));
}






 
static __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (6));
}





 
static __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (6));
}






 
static __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (7));
}





 
static __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (7));
}





 
static __inline void TIMER_EnableInt(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (29));
}





 
static __inline void TIMER_DisableInt(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (29));
}





 
static __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (5));
}





 
static __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (5));
}







 
static __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
{
    return(timer->INTSTS & (0x1ul << (0)) ? 1 : 0);
}





 
static __inline void TIMER_ClearIntFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (0));
}







 
static __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
{
    return timer->EINTSTS;
}





 
static __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
{
    timer->EINTSTS = (0x1ul << (0));
}







 
static __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
{
    return (timer->INTSTS & (0x1ul << (1)) ? 1 : 0);
}





 
static __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (1));
}





 
static __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
{
    return timer->CAP;
}





 
static __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
{
    return timer->CNT;
}

uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
void TIMER_Close(TIMER_T *timer);
void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
void TIMER_DisableCapture(TIMER_T *timer);
void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
void TIMER_DisableEventCounter(TIMER_T *timer);
uint32_t TIMER_GetModuleClock(TIMER_T *timer);


   

   

   







 
#line 32771 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\uart.h"
 








 













 



 



 

 
 
 











 
 
 
















 
 
 



 
 
 




 
 
 





   




 











 










 











 









 










 










 









 










 











 












 












 










 










 



















 


















 





















 








 
static __inline void UART_CLEAR_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9));
    uart->MODEM &= (0x1ul << (1));
}






 
static __inline void UART_SET_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
}







 









 



void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
void UART_Close(UART_T* uart );
void UART_DisableFlowCtrl(UART_T* uart );
void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
void UART_EnableFlowCtrl(UART_T* uart );
void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
void UART_Open(UART_T* uart, uint32_t u32baudrate);
uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);


   

   

   







 




#line 32772 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"
 








 











 



 



 







#line 51 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 




 
#line 69 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 
#line 80 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 



 
#line 93 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 







 



 





 
#line 123 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"

 
#line 132 "..\\..\\..\\..\\Library\\StdDriver\\inc\\usbd.h"


   



 

typedef void (*CLASS_REQ)(void);
typedef void (*SET_INTERFACE_REQ)(uint32_t u32AltInterface);

 
typedef struct USBD_CMD_STRUCT {
    uint8_t  bmRequestType;
    uint8_t  bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;

} S_USBD_CMD_T;



 
typedef struct s_usbd_info {
    uint8_t *gu8DevDesc;
    uint8_t *gu8ConfigDesc;
    uint8_t *gu8StrLangDesc;
    uint8_t *gu8StrVendorDesc;
    uint8_t *gu8StrProductDesc;
    uint8_t *gu8QualDesc;
    uint8_t *gu8OtherConfigDesc;
    uint8_t *gu8HidReportDesc;

} S_USBD_INFO_T;


   


extern uint32_t volatile g_usbd_DmaDone;
extern uint32_t g_usbd_UsbAddr;
extern uint32_t g_usbd_CtrlInSize;
extern uint32_t g_usbd_ShortPacket;
extern uint32_t g_usbd_CtrlZero;
extern uint8_t g_usbd_EpHalt[];
extern S_USBD_INFO_T gsInfo;
extern S_USBD_CMD_T gUsbCmd;




 





































































   



 






 
static __inline void USBD_MemCopy(uint8_t *u8Dst, uint8_t *u8Src, int32_t i32Size)
{
    while (i32Size--) *u8Dst++ = *u8Src++;
}





 
static __inline void USBD_ResetDMA(void)
{
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACNT = 0;
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACTL = 0x80;
    ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->DMACTL = 0x00;
}






 
static __inline void USBD_SetEpBufAddr(uint32_t u32Ep, uint32_t u32Base, uint32_t u32Len)
{
    if (u32Ep == 0xff) {
        ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPBUFSTART = u32Base;
        ((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPBUFEND   = u32Base + u32Len - 1;
    } else {
        *((volatile uint32_t *) ((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPABUFSTART + (uint32_t)(u32Ep*0x28))) = u32Base;
        *((volatile uint32_t *) ((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPABUFEND + (uint32_t)(u32Ep*0x28))) = u32Base + u32Len - 1;
    }
}








 
static __inline void USBD_ConfigEp(uint32_t u32Ep, uint32_t u32EpNum, uint32_t u32EpType, uint32_t u32EpDir)
{
    if (u32EpType == ((uint32_t)0x00000002))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000000));
    else if (u32EpType == ((uint32_t)0x00000004))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000002));
    else if (u32EpType == ((uint32_t)0x00000006))
        *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL+(uint32_t)(u32Ep*0x28)))=(((uint32_t)0x00000001)|((uint32_t)0x00000004));

    *((volatile uint32_t *)((uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPACFG+(uint32_t)(u32Ep*0x28)))=(u32EpType|u32EpDir|((uint32_t)0x00000001)|(u32EpNum << 4));
}








 
static __inline void USBD_SetStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;
    uint32_t u32Cfg;

    if (u32Ep == 0)
        (((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->CEPCTL = ((uint32_t)0x00000002));

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);
    u32Cfg = *((volatile uint32_t *) (u32CfgAddr)) & 0xf7;   
    *((volatile uint32_t *) (u32CfgAddr)) = (u32Cfg | ((uint32_t)0x00000010));
}








 
static __inline void USBD_ClearStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);
    *((volatile uint32_t *) (u32CfgAddr)) = ((uint32_t)0x00000008);
}









 
static __inline uint32_t USBD_GetStall(uint32_t u32Ep)
{
    uint32_t u32CfgAddr;

    u32CfgAddr = (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x19000))->EPARSPCTL + (uint32_t)(u32Ep * 0x28);

    return ((*((volatile uint32_t *) (u32CfgAddr))) & ((uint32_t)0x00000010));
}


 
void USBD_Open(S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
void USBD_Start(void);
void USBD_ProcessSetupPacket(void);
void USBD_StandardRequest(void);
void USBD_UpdateDeviceState(void);
void USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
void USBD_CtrlIn(void);
void USBD_CtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
void USBD_SwReset(void);



   

   

   







 
#line 32773 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wdt.h"
 








 











 



 



 
#line 39 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wdt.h"






   




 






 







 







 








 








 








 







 






 
static __inline void WDT_Close(void)
{
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL = 0;
    return;
}





 
static __inline void WDT_EnableInt(void)
{
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL |= (0x1ul << (6));
    return;
}





 
static __inline void WDT_DisableInt(void)
{
    
    ((WDT_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0x00000))->CTL &= ~((0x1ul << (6)) | (0x1ul << (2)) | (0x1ul << (3))) ;
    return;
}

void  WDT_Open(uint32_t u32TimeoutInterval,
               uint32_t u32ResetDelay,
               uint32_t u32EnableReset,
               uint32_t u32EnableWakeup);

   

   

   







 
#line 32774 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wwdt.h"
 








 











 



 



 
#line 47 "..\\..\\..\\..\\Library\\StdDriver\\inc\\wwdt.h"


   




 






 







 








 








 







 










 



void WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);


   

   

   







 
#line 32775 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"









 



#line 1 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
 









 






































 

















































 
#line 32785 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"

 
#line 15 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"








 



 



 





 



 





 



 



 
#line 64 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"

#line 73 "..\\..\\..\\..\\Library\\StdDriver\\inc\\i2s.h"

 



 



   



 
 
 
 








 
static __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == 0)
        i2s->CTL |= (0x1ul << (16));
    else
        i2s->CTL |= (0x1ul << (17));
}









 
static __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == 0)
        i2s->CTL &= ~(0x1ul << (16));
    else
        i2s->CTL &= ~(0x1ul << (17));
}






 







 







 







 







 







 







 







 







 







 







 







 










 
static __inline void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
{
    u32Ch == (0x1ul << (23)) ?
    (i2s->CTL |= (0x1ul << (23))) :
    (i2s->CTL &= ~(0x1ul << (23)));
}







 







 








 








 







 







 


uint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat, uint32_t u32AudioInterface);
void I2S_Close(I2S_T *i2s);
void I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
void I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
uint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
void I2S_DisableMCLK(I2S_T *i2s);

   


   

   



 

#line 32776 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\can.h"
 








 










 



 



 



 
typedef enum {
    CAN_STD_ID = 0,  
    CAN_EXT_ID = 1   
} E_CAN_ID_TYPE;



 
typedef enum {
    REMOTE_FRAME = 0,   
    DATA_FRAME   = 1    
} E_CAN_FRAME_TYPE;



 
typedef struct {
    uint32_t  IdType;      
    uint32_t  FrameType;   
    uint32_t  Id;          
    uint8_t   DLC;         
    uint8_t   Data[8];     
} STR_CANMSG_T;



 
typedef struct {
    uint8_t   u8Xtd;      
    uint8_t   u8Dir;      
    uint32_t  u32Id;      
    uint8_t   u8IdType;   
} STR_CANMASK_T;



 
typedef enum {
    CAN_NOTMAL_MODE = 1,  
    CAN_BASIC_MODE = 2    
} CAN_MODE_SELECT;





   




 








 









 









 









 










 



 
 
 
uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate);
uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode);
int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum);
void CAN_EnableInt(CAN_T  *tCAN, uint32_t u32Mask);
void CAN_DisableInt(CAN_T  *tCAN, uint32_t u32Mask);
int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID);
int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID);
int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum);

   

   

   







 





#line 32777 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"
 








 
#line 12 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"






 



 




 

















 
#line 56 "..\\..\\..\\..\\Library\\StdDriver\\inc\\sd.h"












   



 
typedef struct SD_info_t {
    uint32_t    CardType;     
    uint32_t    RCA;          
    uint8_t IsCardInsert;     
} SD_INFO_T;

 
typedef struct disk_data_t {
    struct disk_data_t  *next;     

     
    unsigned int  totalSectorN;    
    unsigned int  diskSize;        
    int           sectorSize;      
    char          vendor[32];   
    char          product[32];  
    char          serial[32];   
} DISK_DATA_T;

   

extern SD_INFO_T SD0;
extern SD_INFO_T SD1;



 














 












 















 














 











 









 



void SD_Open(uint32_t u32CardDetSrc);
void SD_Probe(uint32_t u32CardNum);
uint32_t SD_Read(uint32_t u32CardNum, uint8_t *pu8BufAddr, uint32_t u32StartSec, uint32_t u32SecCount);
uint32_t SD_Write(uint32_t u32CardNum, uint8_t *pu8BufAddr, uint32_t u32StartSec, uint32_t u32SecCount);



   

   

   


 
#line 32778 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"
#line 1 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ps2.h"
 








 



 
 
 
#line 18 "..\\..\\..\\..\\Library\\StdDriver\\inc\\ps2.h"









 



 




 

 
 
 








 










 









 









 
static __inline void PS2_CLEAR_TX_FIFO(void) 
{
    ((PS2_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0xA0000))->CTL |= (0x1ul << (8)); 
    ((PS2_T *) ((((uint32_t)0x40000000) + 0x00040000) + 0xA0000))->CTL &= ~(0x1ul << (8));
}








 









 










 









 









 









 









 









 









 









 









 









 



 
 
 

void PS2_Open(void);
void PS2_Close(void);
uint8_t PS2_Read(void);
int32_t PS2_Write(uint32_t *pu32Buf, uint32_t u32ByteCount);
void PS2_EnableInt(uint32_t u32Mask);
void PS2_DisableInt(uint32_t u32Mask);


   

   

   







 

#line 32779 "..\\..\\..\\..\\Library\\Device\\Nuvoton\\NUC472_442\\Include\\NUC472_442.h"







 
#line 14 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"



 



 







 







#line 44 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"


#line 52 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"























#line 82 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"








#line 101 "..\\..\\..\\..\\Library\\StdDriver\\src\\emac.c"

   



 

 
typedef struct {
    uint32_t u32Status1;   
    uint32_t u32Data;      
    uint32_t u32Status2;   
    uint32_t u32Next;      
    uint32_t u32Backup1;   
    uint32_t u32Backup2;   
} EMAC_DESCRIPTOR_T;

 
typedef struct {
    uint8_t au8Buf[1520];
} EMAC_FRAME_T;

   


static volatile EMAC_DESCRIPTOR_T rx_desc[4];
static volatile EMAC_FRAME_T rx_buf[4];
static volatile EMAC_DESCRIPTOR_T tx_desc[4];
static volatile EMAC_FRAME_T tx_buf[4];


static uint32_t u32CurrentTxDesc, u32NextTxDesc, u32CurrentRxDesc;
static uint32_t s_u32EnableTs = 0;



 





 






 








 
static void EMAC_MdioWrite(uint32_t u32Reg, uint32_t u32Addr, uint32_t u32Data)
{
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMDAT = u32Data ;
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMCTL = u32Reg | (u32Addr << 8) | (0x1ul << (17)) | (0x1ul << (16)) | (0x1ul << (19));
    
    while(((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMCTL & (0x1ul << (17)));

}






 
static uint32_t EMAC_MdioRead(uint32_t u32Reg, uint32_t u32Addr)
{
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMCTL = u32Reg | (u32Addr << (8)) | (0x1ul << (17)) | (0x1ul << (19));
    
    while(((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMCTL & (0x1ul << (17)));
    
    return ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->MIIMDAT;
}






 

  volatile uint16_t	k;
static void EMAC_PhyInit(void)
{
     uint32_t reg;

    
    EMAC_MdioWrite(0x00, 1, (1 << 15));

    
    while (1) {
        reg = EMAC_MdioRead(0x00, 1) ;
        if ((reg & (1 << 15))==0)
            break;
    }

    if(!EMAC_MdioRead(0x01, 1) & (1 << 3)) {     
        ;
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (20));
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (18));
        return;
    }

	

    
    EMAC_MdioWrite(0x04, 1, (1 << 8) |
                   (1 << 7) |
                   (1 << 6) |
                   (1 << 5) |
                   (1 << 0));
    
    EMAC_MdioWrite(0x00, 1, EMAC_MdioRead(0x00, 1) | (1 << 9));

    
    while(!(EMAC_MdioRead(0x01, 1) & (1 << 5)));

    
    while(!(EMAC_MdioRead(0x01, 1) & (1 << 3)));




    
    reg = EMAC_MdioRead(0x05, 1) ;
    if (reg & (1 << 8)) {
        ;
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL |= (0x1ul << (20));
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL |= (0x1ul << (18));
    } else if (reg & (1 << 7)) {
        ;
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL |= (0x1ul << (20));
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (18));
    } else if (reg & (1 << 6)) {
        ;
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (20));
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL |= (0x1ul << (18));
    } else {
        ;
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (20));
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL &= ~(0x1ul << (18));
    }


	 reg = EMAC_MdioRead(2, 1) ;
	   k= reg&0xffff;
	 reg = EMAC_MdioRead(3, 1) ;
	  k= reg&0xffff;
	 reg = EMAC_MdioRead(16, 1) ;
	  k= reg&0xffff;
	 EMAC_MdioWrite(16, 1, 0x2);
	  k= reg&0xffff;
	 reg = EMAC_MdioRead(16, 1) ;
	  k= reg&0xffff;

}





 
static void EMAC_TxDescInit(void)
{
    uint32_t i;

    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TXDSA = (uint32_t)&tx_desc[0];
    u32NextTxDesc = u32CurrentTxDesc = (uint32_t)&tx_desc[0];

    for(i = 0; i < 4; i++) {

        if(s_u32EnableTs)
            tx_desc[i].u32Status1 = 0x01 | 0x02 | 0x04;
        else
            tx_desc[i].u32Status1 = 0x01 | 0x02 | 0x04 | 0x08;

        tx_desc[i].u32Data = (uint32_t)((uint32_t)&tx_buf[i]);
        tx_desc[i].u32Backup1 = tx_desc[i].u32Data;
        tx_desc[i].u32Status2 = 0;
        tx_desc[i].u32Next = (uint32_t)&tx_desc[(i + 1) % 4];
        tx_desc[i].u32Backup2 = tx_desc[i].u32Next;

    }

}






 
static void EMAC_RxDescInit(void)
{

    uint32_t i;

    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->RXDSA = (uint32_t)&rx_desc[0];
    u32CurrentRxDesc = (uint32_t)&rx_desc[0];

    for(i=0; i < 4; i++) {
        rx_desc[i].u32Status1 = 0x80000000;
        rx_desc[i].u32Data = (uint32_t)((uint32_t)&rx_buf[i]);
        rx_desc[i].u32Backup1 = rx_desc[i].u32Data;
        rx_desc[i].u32Status2 = 0;
        rx_desc[i].u32Next = (uint32_t)&rx_desc[(i + 1) % 4];
        rx_desc[i].u32Backup2 = rx_desc[i].u32Next;
    }

}





 
static uint32_t EMAC_Subsec2Nsec(uint32_t subsec)
{
    
    uint64_t i;
    i = 1000000000ll * subsec;
    i >>= 31;
    return(i);
}





 
static uint32_t EMAC_Nsec2Subsec(uint32_t nsec)
{
    
    uint64_t i;
    i = (1ll << 31) * nsec;
    i /= 1000000000;
    return(i);
}


   








 












 
void EMAC_Open(uint8_t *pu8MacAddr)
{
    
    EMAC_TxDescInit();
    EMAC_RxDescInit();

    
    EMAC_SetMacAddr(pu8MacAddr);

    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTEN = (0x1ul << (0)) |
                  (0x1ul << (16)) |
                  (0x1ul << (4)) |
                  (0x1ul << (18)) |
                  (0x1ul << (11)) |
                  (0x1ul << (24)) |
                  (0x1ul << (10)) |
                  (0x1ul << (28)) |
                  (0x1ul << (15));

    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL = (0x1ul << (5)) |
                (0x1ul << (22)) |
                (0x1ul << (19));

    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CAMCTL =  (0x1ul << (4)) |
                    (0x1ul << (1)) |
                    (0x1ul << (2));

    EMAC_PhyInit();
}





 

void EMAC_Close(void)
{
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTL |= (0x1ul << (24));
}





 
void EMAC_SetMacAddr(uint8_t *pu8MacAddr)
{
    EMAC_EnableCamEntry(0, pu8MacAddr);

}






 
void EMAC_EnableCamEntry(uint32_t u32Entry, uint8_t *pu8MacAddr)
{
    uint32_t u32Lsw, u32Msw;

    u32Lsw = (pu8MacAddr[4] << 24) |
             (pu8MacAddr[5] << 16);
    u32Msw = (pu8MacAddr[0] << 24)|
             (pu8MacAddr[1] << 16)|
             (pu8MacAddr[2] << 8)|
             pu8MacAddr[3];

    *(uint32_t volatile *)(&((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CAM0M + u32Entry * 4) = u32Msw;
    *(uint32_t volatile *)(&((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CAM0L + u32Entry * 4) = u32Lsw;

    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CAMEN |= (1 << u32Entry);
}





 
void EMAC_DisableCamEntry(uint32_t u32Entry)
{
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CAMEN &= ~(1 << u32Entry);
}










 
uint32_t EMAC_RecvPkt(uint8_t *pu8Data, uint32_t *pu32Size)
{
    EMAC_DESCRIPTOR_T *desc;
    uint32_t status, reg;
    uint32_t u32Count = 0;

    
    reg = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS = reg & 0xFFFF;  

    if (reg & (0x1ul << (11))) {
        
        ;
    } else {

        
        desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;

        
        if(((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CRXDSA == (uint32_t)desc)
            return(0);
        if ((desc->u32Status1 | 0x80000000) != 0x80000000) { 

            status = desc->u32Status1 >> 16;

            
            if(status & 0x0010) {
                
                *pu32Size = desc->u32Status1 & 0xffff;
                memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);
                u32Count = 1;
            } else {
                
                if (status & 0x0040);
                if (status & 0x0020);
                if (status & 0x0008);
                if (status & 0x0002);
            }
        }
    }
    return(u32Count);
}













 
uint32_t EMAC_RecvPktTS(uint8_t *pu8Data, uint32_t *pu32Size, uint32_t *pu32Sec, uint32_t *pu32Nsec)
{
    EMAC_DESCRIPTOR_T *desc;
    uint32_t status, reg;
    uint32_t u32Count = 0;

    
    reg = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS = reg & 0xFFFF; 

    if (reg & (0x1ul << (11))) {
        
        ;
    } else {

        
        desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;

        
        if(((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CRXDSA == (uint32_t)desc)
            return(0);
        if ((desc->u32Status1 | 0x80000000) != 0x80000000) { 

            status = desc->u32Status1 >> 16;

            
            if(status & 0x0010) {
                
                *pu32Size = desc->u32Status1 & 0xffff;
                memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);

                *pu32Sec = desc->u32Next; 
                *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); 

                u32Count = 1;
            } else {
                
                if (status & 0x0040);
                if (status & 0x0020);
                if (status & 0x0008);
                if (status & 0x0002);
            }
        }
    }
    return(u32Count);
}







 
void EMAC_RecvPktDone(void)
{
    EMAC_DESCRIPTOR_T *desc;
    
    desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;

    
    desc->u32Data = desc->u32Backup1;
    desc->u32Next = desc->u32Backup2;

    
    desc->u32Status1 |= 0x80000000;

    
    desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;

    
    u32CurrentRxDesc = (uint32_t)desc;

    do{((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->RXST = 0;}while(0);
}











 
uint32_t EMAC_SendPkt(uint8_t *pu8Data, uint32_t u32Size)
{
    EMAC_DESCRIPTOR_T *desc;
    uint32_t status;

    
    desc = (EMAC_DESCRIPTOR_T *)u32NextTxDesc;

    status = desc->u32Status1;

    
    if((status & 0x80000000))
        return(0);

    memcpy((uint8_t *)desc->u32Data, pu8Data, u32Size);

    
    desc->u32Status2 = u32Size;

    
    desc->u32Status1 |= 0x80000000;

    
    u32NextTxDesc = (uint32_t)(desc->u32Next);

    
    do{((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TXST = 0;}while(0);

    return(1);
}








 
uint32_t EMAC_SendPktDone(void)
{
    EMAC_DESCRIPTOR_T *desc;
    uint32_t status, reg;
    uint32_t last_tx_desc;
    uint32_t u32Count = 0;

    reg = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS;
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS = reg & (0xFFFF0000 & ~(0x1ul << (28)));


    if (reg & (0x1ul << (24))) {
        
        ;
    } else {
        
        last_tx_desc = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->CTXDSA ;
        
        desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;
        do {
            
            if(desc->u32Status1 & 0x80000000)
                break;
            
            status = desc->u32Status2 >> 16;
            if (status & 0x0008) {
                u32Count++;
            } else {
                
                if (status & 0x0040);
                if (status & 0x0002);
                if (status & 0x0200);
                if (status & 0x0010);
                if (status & 0x0020);
                if (status & 0x0400);
                if (status & 0x0080);
                if (status & 0x0100);
            }

            
            desc->u32Data = desc->u32Backup1;
            desc->u32Next = desc->u32Backup2;
            
            desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
        } while (last_tx_desc != (uint32_t)desc);    
        
        u32CurrentTxDesc = (uint32_t)desc;
    }
    return(u32Count);
}










 
uint32_t EMAC_SendPktDoneTS(uint32_t *pu32Sec, uint32_t *pu32Nsec)
{

    EMAC_DESCRIPTOR_T *desc;
    uint32_t status, reg;
    uint32_t u32Count = 0;

    reg = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS;
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->INTSTS = reg & (0xFFFF0000 & ~(0x1ul << (28)));


    if (reg & (0x1ul << (24))) {
        
        ;
    } else {
        
        
        desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;

        
        if(desc->u32Status1 & 0x80000000)
            return(0);
        
        status = desc->u32Status2 >> 16;
        if (status & 0x0008) {
            u32Count = 1;
            *pu32Sec = desc->u32Next; 
            *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); 
        } else {
            
            if (status & 0x0040);
            if (status & 0x0002);
            if (status & 0x0200);
            if (status & 0x0010);
            if (status & 0x0020);
            if (status & 0x0400);
            if (status & 0x0080);
            if (status & 0x0100);
        }

        
        desc->u32Data = desc->u32Backup1;
        desc->u32Next = desc->u32Backup2;
        
        desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;

        
        u32CurrentTxDesc = (uint32_t)desc;
    }

    return(u32Count);
}







 
void EMAC_EnableTS(uint32_t u32Sec, uint32_t u32Nsec)
{
    double f;
    uint32_t reg;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL = (0x1ul << (0));
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSEC = u32Sec;   
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);

    
    
    
    
    
    
    
    
    f = (100.0 * 2147483648.0) / (1000000000.0) + 0.5;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSINC = (reg = (uint32_t)f);
    f = (double)9223372036854775808.0 / ((double)(CLK_GetHCLKFreq()) * (double)reg);
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSADDEND = (uint32_t)f;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL |= ((0x1ul << (3)) | (0x1ul << (1)) | (0x1ul << (2))); 
}





 
void EMAC_DisableTS(void)
{
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL = 0;
}






 
void EMAC_GetTime(uint32_t *pu32Sec, uint32_t *pu32Nsec)
{
    
    *pu32Nsec = EMAC_Subsec2Nsec(((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSSUBSEC);
    *pu32Sec = ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSSEC;
}






 
void EMAC_SetTime(uint32_t u32Sec, uint32_t u32Nsec)
{
    
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL = (0x1ul << (0));
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSEC = u32Sec;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL |= ((0x1ul << (1)) | (0x1ul << (2)));

}






 
void EMAC_EnableAlarm(uint32_t u32Sec, uint32_t u32Nsec)
{

    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->ALMSEC = u32Sec;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->ALMSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL |= (0x1ul << (5));

}





 
void EMAC_DisableAlarm(void)
{

    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL &= ~(0x1ul << (5));

}







 
void EMAC_UpdateTime(uint32_t u32Neg, uint32_t u32Sec, uint32_t u32Nsec)
{
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSEC = u32Sec;
    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
    if(u32Neg)
        ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->UPDSUBSEC |= (0x80000000);   

    ((EMAC_T *) (((uint32_t)0x40000000) + 0x0B000))->TSCTL |= (0x1ul << (3));

}


   

   

   

 
