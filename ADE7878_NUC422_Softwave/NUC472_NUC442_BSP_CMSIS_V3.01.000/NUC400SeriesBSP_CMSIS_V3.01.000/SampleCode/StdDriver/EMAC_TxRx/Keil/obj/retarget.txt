; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\retarget.o --depend=.\obj\retarget.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC472_442\Include -I..\..\..\..\Library\StdDriver\inc -IE:\Keil\ARM\INC -IE:\Keil\ARM\INC\ARM --omf_browse=.\obj\retarget.crf ..\..\..\..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;398      */
;;;399    char GetChar(void)
000000  e008              B        |L1.20|
                  |L1.2|
;;;400    {
;;;401    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;402    # if defined ( __CC_ARM   )
;;;403        int nRet;
;;;404        while(SH_DoCommand(0x101, 0, &nRet) != 0) {
;;;405            if(nRet != 0) {
;;;406                SH_DoCommand(0x07, 0, &nRet);
;;;407                return (char)nRet;
;;;408            }
;;;409        }
;;;410    # else
;;;411        int nRet;
;;;412        while(SH_DoCommand(0x7, 0, &nRet) != 0) {
;;;413            if(nRet != 0)
;;;414                return (char)nRet;
;;;415        }
;;;416    # endif
;;;417    #endif
;;;418    
;;;419    #ifndef DISABLE_UART
;;;420        while (1) {
;;;421            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0 ) {
000002  4805              LDR      r0,|L1.24|
000004  6980              LDR      r0,[r0,#0x18]
000006  f4104f80          TST      r0,#0x4000
00000a  d103              BNE      |L1.20|
;;;422                return (DEBUG_PORT->DAT);
00000c  4802              LDR      r0,|L1.24|
00000e  6800              LDR      r0,[r0,#0]
000010  b2c0              UXTB     r0,r0
;;;423    
;;;424            }
;;;425        }
;;;426    #else
;;;427        return(0);
;;;428    #endif
;;;429    }
000012  4770              BX       lr
                  |L1.20|
000014  e7f5              B        |L1.2|
;;;430    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40070000

                          AREA ||i.Hard_Fault_Handler||, CODE, READONLY, ALIGN=2

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;60      */
;;;61     void Hard_Fault_Handler(uint32_t stack[])
000000  4604              MOV      r4,r0
;;;62     {
;;;63         printf("In Hard Fault Handler\n");
000002  a004              ADR      r0,|L2.20|
000004  f7fffffe          BL       __2printf
;;;64     
;;;65         stackDump(stack);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       stackDump
;;;66         // Replace while(1) with chip reset if WDT is not enabled for end product
;;;67         while(1);
00000e  bf00              NOP      
                  |L2.16|
000010  e7fe              B        |L2.16|
;;;68         //SYS->IPRSTC1 = SYS_IPRSTC1_CHIP_RST_Msk;
;;;69     }
;;;70     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
000014  496e2048          DCB      "In Hard Fault Handler\n",0
000018  61726420
00001c  4661756c
000020  74204861
000024  6e646c65
000028  720a00  
00002b  00                DCB      0

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;454      */
;;;455    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L3.12|
;;;456    {
;;;457    #ifndef DISABLE_UART
;;;458        return (DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  f0005080          AND      r0,r0,#0x10000000
;;;459    #else
;;;460        return(1);
;;;461    #endif
;;;462    }
000008  4770              BX       lr
;;;463    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40070000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;368      */
;;;369    void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;370    {
000002  4603              MOV      r3,r0
;;;371    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;372        g_buf[g_buf_len++] = ch;
;;;373        g_buf[g_buf_len] = '\0';
;;;374        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0') {
;;;375    
;;;376            /* Send the char */
;;;377            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0) {
;;;378                g_buf_len = 0;
;;;379                return;
;;;380            } else {
;;;381                int i;
;;;382    
;;;383                for(i=0; i<g_buf_len; i++)
;;;384                    SendChar_ToUART(g_buf[i]);
;;;385                g_buf_len = 0;
;;;386            }
;;;387        }
;;;388    #else
;;;389        SendChar_ToUART(ch);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       SendChar_ToUART
;;;390    #endif
;;;391    }
00000a  bd00              POP      {pc}
;;;392    
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;351      */
;;;352    void SendChar_ToUART(int ch)
000000  bf00              NOP      
                  |L5.2|
;;;353    {
;;;354    #ifndef DISABLE_UART
;;;355        while((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)); //waits for TXFULL bit is clear
000002  4909              LDR      r1,|L5.40|
000004  6989              LDR      r1,[r1,#0x18]
000006  f4110f00          TST      r1,#0x800000
00000a  d1fa              BNE      |L5.2|
;;;356        DEBUG_PORT->DAT = ch;
00000c  4906              LDR      r1,|L5.40|
00000e  6008              STR      r0,[r1,#0]
;;;357        if(ch == '\n') {
000010  280a              CMP      r0,#0xa
000012  d108              BNE      |L5.38|
;;;358            while((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)); //waits for TXFULL bit is clear
000014  bf00              NOP      
                  |L5.22|
000016  4904              LDR      r1,|L5.40|
000018  6989              LDR      r1,[r1,#0x18]
00001a  f4110f00          TST      r1,#0x800000
00001e  d1fa              BNE      |L5.22|
;;;359            DEBUG_PORT->DAT = '\r';
000020  210d              MOVS     r1,#0xd
000022  4a01              LDR      r2,|L5.40|
000024  6011              STR      r1,[r2,#0]
                  |L5.38|
;;;360        }
;;;361    #endif
;;;362    }
000026  4770              BX       lr
;;;363    
                          ENDP

                  |L5.40|
                          DCD      0x40070000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;470    
;;;471    void _ttywrch(int ch)
000000  b510              PUSH     {r4,lr}
;;;472    {
000002  4604              MOV      r4,r0
;;;473        SendChar(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar
;;;474        return;
;;;475    }
00000a  bd10              POP      {r4,pc}
;;;476    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;515      */
;;;516    int ferror(FILE *stream)
000000  4601              MOV      r1,r0
;;;517    {
;;;518        return EOF;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;519    }
000006  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;501      */
;;;502    int fgetc(FILE *stream)
000000  b500              PUSH     {lr}
;;;503    {
000002  4601              MOV      r1,r0
;;;504        return (GetChar());
000004  f7fffffe          BL       GetChar
;;;505    }
000008  bd00              POP      {pc}
;;;506    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;488      */
;;;489    int fputc(int ch, FILE *stream)
000000  b530              PUSH     {r4,r5,lr}
;;;490    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;491        SendChar(ch);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendChar
;;;492        return ch;
00000c  4620              MOV      r0,r4
;;;493    }
00000e  bd30              POP      {r4,r5,pc}
;;;494    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;438      */
;;;439    int kbhit(void)
000000  4802              LDR      r0,|L10.12|
;;;440    {
;;;441    #ifndef DISABLE_UART
;;;442        return !(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXFULL_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  ea2130d0          BIC      r0,r1,r0,LSR #15
;;;443    #else
;;;444        return(0);
;;;445    #endif
;;;446    }
00000a  4770              BX       lr
;;;447    
                          ENDP

                  |L10.12|
                          DCD      0x40070000

                          AREA ||i.stackDump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;42      */
;;;43     static void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;44     {   
000002  4604              MOV      r4,r0
;;;45         printf("r0  = 0x%x\n", stack[r0]);
000004  a010              ADR      r0,|L11.72|
000006  6821              LDR      r1,[r4,#0]
000008  f7fffffe          BL       __2printf
;;;46         printf("r1  = 0x%x\n", stack[r1]);
00000c  a011              ADR      r0,|L11.84|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;47         printf("r2  = 0x%x\n", stack[r2]);
000014  a012              ADR      r0,|L11.96|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;48         printf("r3  = 0x%x\n", stack[r3]);
00001c  a013              ADR      r0,|L11.108|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;49         printf("r12 = 0x%x\n", stack[r12]);
000024  a014              ADR      r0,|L11.120|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;50         printf("lr  = 0x%x\n", stack[lr]);
00002c  a015              ADR      r0,|L11.132|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;51         printf("pc  = 0x%x\n", stack[pc]);
000034  a016              ADR      r0,|L11.144|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;52         printf("psr = 0x%x\n", stack[psr]);
00003c  a017              ADR      r0,|L11.156|
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  f7fffffe          BL       __2printf
;;;53     }
000044  bd10              POP      {r4,pc}
;;;54     
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
000048  72302020          DCB      "r0  = 0x%x\n",0
00004c  3d203078
000050  25780a00
                  |L11.84|
000054  72312020          DCB      "r1  = 0x%x\n",0
000058  3d203078
00005c  25780a00
                  |L11.96|
000060  72322020          DCB      "r2  = 0x%x\n",0
000064  3d203078
000068  25780a00
                  |L11.108|
00006c  72332020          DCB      "r3  = 0x%x\n",0
000070  3d203078
000074  25780a00
                  |L11.120|
000078  72313220          DCB      "r12 = 0x%x\n",0
00007c  3d203078
000080  25780a00
                  |L11.132|
000084  6c722020          DCB      "lr  = 0x%x\n",0
000088  3d203078
00008c  25780a00
                  |L11.144|
000090  70632020          DCB      "pc  = 0x%x\n",0
000094  3d203078
000098  25780a00
                  |L11.156|
00009c  70737220          DCB      "psr = 0x%x\n",0
0000a0  3d203078
0000a4  25780a00

                          AREA ||.data||, DATA, ALIGN=2

                  u32EscapeFrame
                          DCD      0x00000000
                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_retarget_c_d5a1b03f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REVSH|
#line 128
|__asm___10_retarget_c_d5a1b03f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |HardFault_Handler|
#line 325 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 326

 MOVS r0, #4
 MOV r1, LR
 TST r0, r1
 BEQ Stack_Use_MSP
 MRS R0, PSP 
 B Get_LR_and_Branch
Stack_Use_MSP
 MRS R0, MSP 
Get_LR_and_Branch
 MOV R1, LR 
 LDR R2,= |Hard_Fault_Handler|
 BX R2
	ENDP

;*** End   embedded assembler ***
