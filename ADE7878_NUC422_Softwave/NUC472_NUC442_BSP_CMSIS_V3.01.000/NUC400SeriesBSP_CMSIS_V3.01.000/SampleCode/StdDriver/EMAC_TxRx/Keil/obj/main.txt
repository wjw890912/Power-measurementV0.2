; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC472_442\Include -I..\..\..\..\Library\StdDriver\inc -IE:\Keil\ARM\INC -IE:\Keil\ARM\INC\ARM --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.EMAC_RX_IRQHandler||, CODE, READONLY, ALIGN=2

                  EMAC_RX_IRQHandler PROC
;;;46       */
;;;47     void EMAC_RX_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49     
;;;50         while(1) {
000002  e00c              B        |L1.30|
                  |L1.4|
;;;51             // Check if there's any packets available
;;;52             if(EMAC_RecvPkt(auPkt, &u32PktLen) == 0)
000004  4907              LDR      r1,|L1.36|
000006  4808              LDR      r0,|L1.40|
000008  f7fffffe          BL       EMAC_RecvPkt
00000c  b900              CBNZ     r0,|L1.16|
;;;53                 break;
00000e  e007              B        |L1.32|
                  |L1.16|
;;;54             // Process receive packet
;;;55             process_rx_packet(auPkt, u32PktLen);
000010  4804              LDR      r0,|L1.36|
000012  6801              LDR      r1,[r0,#0]  ; u32PktLen
000014  4804              LDR      r0,|L1.40|
000016  f7fffffe          BL       process_rx_packet
;;;56             // Clean up Rx resource occupied by previous received packet
;;;57             EMAC_RecvPktDone();
00001a  f7fffffe          BL       EMAC_RecvPktDone
                  |L1.30|
00001e  e7f1              B        |L1.4|
                  |L1.32|
000020  bf00              NOP                            ;53
;;;58         }
;;;59     }
000022  bd10              POP      {r4,pc}
;;;60     
                          ENDP

                  |L1.36|
                          DCD      u32PktLen
                  |L1.40|
                          DCD      auPkt

                          AREA ||i.EMAC_TX_IRQHandler||, CODE, READONLY, ALIGN=1

                  EMAC_TX_IRQHandler PROC
;;;35       */
;;;36     void EMAC_TX_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;37     {
;;;38         // Clean up Tx resource occupied by previous sent packet(s)
;;;39         EMAC_SendPktDone();
000002  f7fffffe          BL       EMAC_SendPktDone
;;;40     }
000006  bd10              POP      {r4,pc}
;;;41     
                          ENDP


                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1453   {
;;;1454   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1455     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  f04f23e0          MOV      r3,#0xe000e000
00000e  eb030282          ADD      r2,r3,r2,LSL #2
000012  f8c21100          STR      r1,[r2,#0x100]
;;;1456   }
000016  4770              BX       lr
;;;1457   
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;60     
;;;61     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63     
;;;64         /*---------------------------------------------------------------------------------------------------------*/
;;;65         /* Init System Clock                                                                                       */
;;;66         /*---------------------------------------------------------------------------------------------------------*/
;;;67         /* Unlock protected registers */
;;;68         SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;69     
;;;70         /* Enable External XTAL (4~24 MHz) */
;;;71         CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;72     
;;;73         /* Waiting for 12MHz clock ready */
;;;74         CLK_WaitClockReady( CLK_STATUS_HXTSTB_Msk);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;75     
;;;76         /* Switch HCLK clock source to HXT */
;;;77         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HXT,CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       CLK_SetHCLK
;;;78     
;;;79         /* Set PLL to power down mode and PLL_STB bit in CLKSTATUS register will be cleared by hardware.*/
;;;80         CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
00001a  481f              LDR      r0,|L4.152|
00001c  6800              LDR      r0,[r0,#0]
00001e  f4403080          ORR      r0,r0,#0x10000
000022  f04f4180          MOV      r1,#0x40000000
000026  f8c10240          STR      r0,[r1,#0x240]
;;;81     
;;;82         /* Set PLL frequency */
;;;83         CLK->PLLCTL = CLK_PLLCTL_84MHz_HXT;
00002a  f244001a          MOV      r0,#0x401a
00002e  491a              LDR      r1,|L4.152|
000030  6008              STR      r0,[r1,#0]
;;;84     
;;;85         /* Waiting for clock ready */
;;;86         CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000032  f04f0004          MOV      r0,#4
000036  f7fffffe          BL       CLK_WaitClockReady
;;;87     
;;;88         /* Switch HCLK clock source to PLL */
;;;89         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL,CLK_CLKDIV0_HCLK(1));
00003a  2100              MOVS     r1,#0
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       CLK_SetHCLK
;;;90     
;;;91         /* Enable IP clock */
;;;92         CLK_EnableModuleClock(UART0_MODULE);
000042  4816              LDR      r0,|L4.156|
000044  f7fffffe          BL       CLK_EnableModuleClock
;;;93         CLK_EnableModuleClock(EMAC_MODULE);
000048  4815              LDR      r0,|L4.160|
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;94     
;;;95         /* Select IP clock source */
;;;96         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HXT, CLK_CLKDIV0_UART(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4812              LDR      r0,|L4.156|
000054  f7fffffe          BL       CLK_SetModuleClock
;;;97     
;;;98         // Configure MDC clock rate to HCLK / (127 + 1) = 656 kHz if system is running at 84 MHz
;;;99         CLK_SetModuleClock(EMAC_MODULE, 0, CLK_CLKDIV3_EMAC(127));
000058  f44f02fc          MOV      r2,#0x7e0000
00005c  2100              MOVS     r1,#0
00005e  4810              LDR      r0,|L4.160|
000060  f7fffffe          BL       CLK_SetModuleClock
;;;100    
;;;101        /* Update System Core Clock */
;;;102        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;103        SystemCoreClockUpdate();
000064  f7fffffe          BL       SystemCoreClockUpdate
;;;104    
;;;105    
;;;106        /*---------------------------------------------------------------------------------------------------------*/
;;;107        /* Init I/O Multi-function                                                                                 */
;;;108        /*---------------------------------------------------------------------------------------------------------*/
;;;109        /* Set GPG multi-function pins for UART0 RXD and TXD */
;;;110        SYS->GPG_MFPL = SYS_GPG_MFPL_PG1MFP_UART0_RXD | SYS_GPG_MFPL_PG2MFP_UART0_TXD ;
000068  f44f7088          MOV      r0,#0x110
00006c  0681              LSLS     r1,r0,#26
00006e  6608              STR      r0,[r1,#0x60]
;;;111        // Configure RMII pins
;;;112        SYS->GPC_MFPL = SYS_GPC_MFPL_PC0MFP_EMAC_REFCLK |
000070  480c              LDR      r0,|L4.164|
000072  6408              STR      r0,[r1,#0x40]
;;;113                        SYS_GPC_MFPL_PC1MFP_EMAC_MII_RXERR |
;;;114                        SYS_GPC_MFPL_PC2MFP_EMAC_MII_RXDV |
;;;115                        SYS_GPC_MFPL_PC3MFP_EMAC_MII_RXD1 |
;;;116                        SYS_GPC_MFPL_PC4MFP_EMAC_MII_RXD0 |
;;;117                        SYS_GPC_MFPL_PC6MFP_EMAC_MII_TXD0 |
;;;118                        SYS_GPC_MFPL_PC7MFP_EMAC_MII_TXD1;
;;;119    
;;;120    
;;;121        SYS->GPC_MFPH = SYS_GPC_MFPH_PC8MFP_EMAC_MII_TXEN;
000074  2006              MOVS     r0,#6
000076  6448              STR      r0,[r1,#0x44]
;;;122        // Enable high slew rate on all RMII pins
;;;123        PC->SLEWCTL |= 0x1DF;
000078  480b              LDR      r0,|L4.168|
00007a  6800              LDR      r0,[r0,#0]
00007c  f24011df          MOV      r1,#0x1df
000080  ea400001          ORR      r0,r0,r1
000084  4908              LDR      r1,|L4.168|
000086  6008              STR      r0,[r1,#0]
;;;124    
;;;125        // Configure MDC, MDIO at PB14 & PB15
;;;126        SYS->GPB_MFPH = SYS_GPB_MFPH_PB14MFP_EMAC_MII_MDC | SYS_GPB_MFPH_PB15MFP_EMAC_MII_MDIO;
000088  f04f40cc          MOV      r0,#0x66000000
00008c  f04f4180          MOV      r1,#0x40000000
000090  63c8              STR      r0,[r1,#0x3c]
;;;127    
;;;128        /* Lock protected registers */
;;;129        SYS_LockReg();
000092  f7fffffe          BL       SYS_LockReg
;;;130    
;;;131    }
000096  bd10              POP      {r4,pc}
;;;132    
                          ENDP

                  |L4.152|
                          DCD      0x40000240
                  |L4.156|
                          DCD      0x57803d10
                  |L4.160|
                          DCD      0x02affe05
                  |L4.164|
                          DCD      0x66066666
                  |L4.168|
                          DCD      0x400040a8

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;135    // IP address is configure with DHCP, but if a lease cannot be acquired, a static IP will be used.
;;;136    int main(void)
000000  f7fffffe          BL       SYS_Init
;;;137    {
;;;138    
;;;139        SYS_Init();
;;;140        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  4819              LDR      r0,|L5.112|
00000a  f7fffffe          BL       UART_Open
;;;141    
;;;142    
;;;143        // Select RMII interface by default
;;;144        EMAC_Open(g_au8MacAddr);
00000e  4819              LDR      r0,|L5.116|
000010  f7fffffe          BL       EMAC_Open
;;;145    
;;;146        NVIC_EnableIRQ(EMAC_TX_IRQn);
000014  205c              MOVS     r0,#0x5c
000016  f7fffffe          BL       NVIC_EnableIRQ
;;;147        NVIC_EnableIRQ(EMAC_RX_IRQn);
00001a  205d              MOVS     r0,#0x5d
00001c  f7fffffe          BL       NVIC_EnableIRQ
;;;148    
;;;149        EMAC_ENABLE_RX();
000020  bf00              NOP      
000022  4815              LDR      r0,|L5.120|
000024  6800              LDR      r0,[r0,#0]
000026  f0400001          ORR      r0,r0,#1
00002a  4914              LDR      r1,|L5.124|
00002c  f8c10090          STR      r0,[r1,#0x90]
000030  f04f0000          MOV      r0,#0
000034  4912              LDR      r1,|L5.128|
000036  6008              STR      r0,[r1,#0]
000038  bf00              NOP      
;;;150        EMAC_ENABLE_TX();
00003a  480f              LDR      r0,|L5.120|
00003c  6800              LDR      r0,[r0,#0]
00003e  f4407080          ORR      r0,r0,#0x100
000042  490e              LDR      r1,|L5.124|
000044  f8c10090          STR      r0,[r1,#0x90]
;;;151    
;;;152        if (dhcp_start() < 0) {
000048  f7fffffe          BL       dhcp_start
00004c  2800              CMP      r0,#0
00004e  da0d              BGE      |L5.108|
;;;153            // Cannot get a DHCP lease, use static IP.
;;;154            printf("DHCP failed, use static IP 192.168.10.10\n");
000050  a00c              ADR      r0,|L5.132|
000052  f7fffffe          BL       __2printf
;;;155            g_au8IpAddr[0] = 0xC0;
000056  f04f00c0          MOV      r0,#0xc0
00005a  4915              LDR      r1,|L5.176|
00005c  7008              STRB     r0,[r1,#0]
;;;156            g_au8IpAddr[1] = 0xA8;
00005e  f04f00a8          MOV      r0,#0xa8
000062  7048              STRB     r0,[r1,#1]
;;;157            g_au8IpAddr[2] = 0x0A;
000064  f04f000a          MOV      r0,#0xa
000068  7088              STRB     r0,[r1,#2]
;;;158            g_au8IpAddr[3] = 0x0A;
00006a  70c8              STRB     r0,[r1,#3]
                  |L5.108|
;;;159        }
;;;160        while(1);
00006c  bf00              NOP      
                  |L5.110|
00006e  e7fe              B        |L5.110|
;;;161    
;;;162    }
;;;163    
                          ENDP

                  |L5.112|
                          DCD      0x40070000
                  |L5.116|
                          DCD      g_au8MacAddr
                  |L5.120|
                          DCD      0x4000b090
                  |L5.124|
                          DCD      0x4000b000
                  |L5.128|
                          DCD      0x4000b0a4
                  |L5.132|
000084  44484350          DCB      "DHCP failed, use static IP 192.168.10.10\n",0
000088  20666169
00008c  6c65642c
000090  20757365
000094  20737461
000098  74696320
00009c  49502031
0000a0  39322e31
0000a4  36382e31
0000a8  302e3130
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L5.176|
                          DCD      g_au8IpAddr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  auPkt
                          %        1514

                          AREA ||.data||, DATA, ALIGN=2

                  u32EscapeFrame
                          DCD      0x00000000
                  g_au8MacAddr
000004  00000059          DCB      0x00,0x00,0x00,0x59
000008  1688              DCB      0x16,0x88
                  g_au8IpAddr
00000a  0000              DCB      0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  u32PktLen
                          DCD      0x00000000
                  u32CurrentTxDesc
                          DCD      0x00000000
                  u32CurrentRxDesc
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_f56aecda____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_f56aecda____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_f56aecda____REVSH|
#line 128
|__asm___6_main_c_f56aecda____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
