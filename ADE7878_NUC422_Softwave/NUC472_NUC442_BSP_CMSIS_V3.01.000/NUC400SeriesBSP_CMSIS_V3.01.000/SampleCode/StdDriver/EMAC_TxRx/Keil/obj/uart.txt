; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\uart.o --depend=.\obj\uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\NUC472_442\Include -I..\..\..\..\Library\StdDriver\inc -IE:\Keil\ARM\INC -IE:\Keil\ARM\INC\ARM --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;41      */
;;;42     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  f4116f80          TST      r1,#0x400
;;;43     {
;;;44         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk) { /* clear Receive Line Status Interrupt */
000004  d007              BEQ      |L1.22|
;;;45             uart->FIFOSTS |= UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000006  6982              LDR      r2,[r0,#0x18]
000008  f0420270          ORR      r2,r2,#0x70
00000c  6182              STR      r2,[r0,#0x18]
;;;46             uart->FIFOSTS |= UART_FIFOSTS_ADDRDETF_Msk;
00000e  6982              LDR      r2,[r0,#0x18]
000010  f0420208          ORR      r2,r2,#8
000014  6182              STR      r2,[r0,#0x18]
                  |L1.22|
;;;47         }
;;;48     
;;;49         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)  /* clear Modem Interrupt */
000016  f4116f00          TST      r1,#0x800
00001a  d003              BEQ      |L1.36|
;;;50             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00001c  6942              LDR      r2,[r0,#0x14]
00001e  f0420201          ORR      r2,r2,#1
000022  6142              STR      r2,[r0,#0x14]
                  |L1.36|
;;;51     
;;;52         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk) { /* clear Buffer Error Interrupt */
000024  f4115f00          TST      r1,#0x2000
000028  d003              BEQ      |L1.50|
;;;53             uart->FIFOSTS |= UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00002a  6982              LDR      r2,[r0,#0x18]
00002c  4b05              LDR      r3,|L1.68|
00002e  431a              ORRS     r2,r2,r3
000030  6182              STR      r2,[r0,#0x18]
                  |L1.50|
;;;54         }
;;;55     
;;;56         if(u32InterruptFlag & UART_INTSTS_RXTOINT_Msk)  /* clear Modem Interrupt */
000032  f4115f80          TST      r1,#0x1000
000036  d003              BEQ      |L1.64|
;;;57             uart->INTSTS |= UART_INTSTS_RXTOIF_Msk;
000038  69c2              LDR      r2,[r0,#0x1c]
00003a  f0420210          ORR      r2,r2,#0x10
00003e  61c2              STR      r2,[r0,#0x1c]
                  |L1.64|
;;;58     
;;;59     }
000040  4770              BX       lr
;;;60     
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;68      */
;;;69     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;70     {
;;;71         uart->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;72     }
000004  4770              BX       lr
;;;73     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;81      */
;;;82     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;83     {
;;;84         uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;85     }
000008  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;103     */
;;;104    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  6842              LDR      r2,[r0,#4]
;;;105    {
;;;106        uart->INTEN &= ~ u32InterruptFlag;
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;107    }
000006  4770              BX       lr
;;;108    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;117     */
;;;118    void UART_EnableFlowCtrl(UART_T* uart )
000000  6901              LDR      r1,[r0,#0x10]
;;;119    {
;;;120        uart->MODEM    |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;121        uart->MODEM    &= UART_MODEM_RTS_Msk;
000008  6901              LDR      r1,[r0,#0x10]
00000a  f0010102          AND      r1,r1,#2
00000e  6101              STR      r1,[r0,#0x10]
;;;122        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  f4417180          ORR      r1,r1,#0x100
000016  6141              STR      r1,[r0,#0x14]
;;;123        uart->INTEN    |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000018  6841              LDR      r1,[r0,#4]
00001a  f4415140          ORR      r1,r1,#0x3000
00001e  6041              STR      r1,[r0,#4]
;;;124    }
000020  4770              BX       lr
;;;125    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;142     */
;;;143    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  6842              LDR      r2,[r0,#4]
;;;144    {
;;;145        uart->INTEN |= u32InterruptFlag;
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;146    }
000006  4770              BX       lr
;;;147    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;156     */
;;;157    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;158    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;159        uint8_t u8UartClkSrcSel;
;;;160        uint32_t u32ClkTbl[4] = {__HXT, 0, __HIRC, __HIRC};
000008  4b1b              LDR      r3,|L7.120|
00000a  cb0f              LDM      r3,{r0-r3}
00000c  e88d000f          STM      sp,{r0-r3}
;;;161        uint32_t u32Clk;
;;;162        uint32_t u32Baud_Div;
;;;163    
;;;164        u32ClkTbl[1] = CLK_GetPLLClockFreq();;
000010  f7fffffe          BL       CLK_GetPLLClockFreq
000014  9001              STR      r0,[sp,#4]
;;;165    
;;;166        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000016  4819              LDR      r0,|L7.124|
000018  6800              LDR      r0,[r0,#0]
00001a  f3c06801          UBFX     r8,r0,#24,#2
;;;167    
;;;168        uart->FUNCSEL = UART_FUNCSEL_UART;
00001e  f04f0000          MOV      r0,#0
000022  6328              STR      r0,[r5,#0x30]
;;;169        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000024  f04f0003          MOV      r0,#3
000028  60e8              STR      r0,[r5,#0xc]
;;;170        uart->FIFO = UART_FIFO_RFITL_1BYTE | UART_FIFO_RTSTRGLV_1BYTE;
00002a  f04f0000          MOV      r0,#0
00002e  60a8              STR      r0,[r5,#8]
;;;171    
;;;172        u32Clk = (u32ClkTbl[u8UartClkSrcSel]) / (((CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos) + 1);
000030  f85d1028          LDR      r1,[sp,r8,LSL #2]
000034  f04f4080          MOV      r0,#0x40000000
000038  f8d00220          LDR      r0,[r0,#0x220]
00003c  f3c02003          UBFX     r0,r0,#8,#4
000040  f1000001          ADD      r0,r0,#1
000044  fbb1f7f0          UDIV     r7,r1,r0
;;;173    
;;;174        if(u32baudrate != 0) {
000048  b19c              CBZ      r4,|L7.114|
;;;175            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
00004a  eb070054          ADD      r0,r7,r4,LSR #1
00004e  fbb0f0f4          UDIV     r0,r0,r4
000052  1e86              SUBS     r6,r0,#2
;;;176    
;;;177            if(u32Baud_Div > 0xFFFF)
000054  f5b63f80          CMP      r6,#0x10000
000058  d308              BCC      |L7.108|
;;;178                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
00005a  eb0700c4          ADD      r0,r7,r4,LSL #3
00005e  fbb0f0f4          UDIV     r0,r0,r4
000062  2102              MOVS     r1,#2
000064  ebc11010          RSB      r0,r1,r0,LSR #4
000068  6268              STR      r0,[r5,#0x24]
00006a  e002              B        |L7.114|
                  |L7.108|
;;;179            else
;;;180                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
00006c  f0465040          ORR      r0,r6,#0x30000000
000070  6268              STR      r0,[r5,#0x24]
                  |L7.114|
;;;181        }
;;;182    }
000072  e8bd81ff          POP      {r0-r8,pc}
;;;183    
                          ENDP

000076  0000              DCW      0x0000
                  |L7.120|
                          DCD      ||.constdata||
                  |L7.124|
                          DCD      0x40000214

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;194     */
;;;195    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b510              PUSH     {r4,lr}
;;;196    {
000002  4603              MOV      r3,r0
;;;197        uint32_t  u32Count;
;;;198    
;;;199        for(u32Count=0; u32Count < u32ReadBytes; u32Count++) {
000004  2000              MOVS     r0,#0
000006  e007              B        |L8.24|
                  |L8.8|
;;;200            if(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) { /* Check RX empty => failed */
000008  699c              LDR      r4,[r3,#0x18]
00000a  f4144f80          TST      r4,#0x4000
00000e  d000              BEQ      |L8.18|
                  |L8.16|
;;;201                return u32Count;
;;;202            }
;;;203            pu8RxBuf[u32Count] = uart->DAT;    /* Get Data from UART RX  */
;;;204        }
;;;205    
;;;206        return u32Count;
;;;207    }
000010  bd10              POP      {r4,pc}
                  |L8.18|
000012  681c              LDR      r4,[r3,#0]            ;203
000014  540c              STRB     r4,[r1,r0]            ;203
000016  1c40              ADDS     r0,r0,#1              ;199
                  |L8.24|
000018  4290              CMP      r0,r2                 ;199
00001a  d3f5              BCC      |L8.8|
00001c  bf00              NOP                            ;206
00001e  e7f7              B        |L8.16|
;;;208    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=1

                  UART_SelectIrDAMode PROC
;;;271     */
;;;272    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  460b              MOV      r3,r1
;;;273    {
;;;274        uart->BAUD = UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(12000000, 57600);
000002  210b              MOVS     r1,#0xb
000004  6241              STR      r1,[r0,#0x24]
;;;275    
;;;276        uart->IRDA    &= ~UART_IRDA_TXINV_Msk;
000006  6a81              LDR      r1,[r0,#0x28]
000008  f0210120          BIC      r1,r1,#0x20
00000c  6281              STR      r1,[r0,#0x28]
;;;277        uart->IRDA    |=  UART_IRDA_RXINV_Msk;
00000e  6a81              LDR      r1,[r0,#0x28]
000010  f0410140          ORR      r1,r1,#0x40
000014  6281              STR      r1,[r0,#0x28]
;;;278        uart->IRDA     =  u32Direction ? uart->IRDA | UART_IRDA_TXEN_Msk : uart->IRDA &~ UART_IRDA_TXEN_Msk;
000016  b11a              CBZ      r2,|L9.32|
000018  6a81              LDR      r1,[r0,#0x28]
00001a  f0410102          ORR      r1,r1,#2
00001e  e002              B        |L9.38|
                  |L9.32|
000020  6a81              LDR      r1,[r0,#0x28]
000022  f0210102          BIC      r1,r1,#2
                  |L9.38|
000026  6281              STR      r1,[r0,#0x28]
;;;279        uart->FUNCSEL  =  (0x2 << UART_FUNCSEL_FUNCSEL_Pos);
000028  2102              MOVS     r1,#2
00002a  6301              STR      r1,[r0,#0x30]
;;;280    }
00002c  4770              BX       lr
;;;281    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;291     */
;;;292    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;293    {
;;;294        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;295        uart->ALTCTL  = 0;
000006  2300              MOVS     r3,#0
000008  62c3              STR      r3,[r0,#0x2c]
;;;296        uart->ALTCTL |= u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos);
00000a  6ac3              LDR      r3,[r0,#0x2c]
00000c  ea416402          ORR      r4,r1,r2,LSL #24
000010  4323              ORRS     r3,r3,r4
000012  62c3              STR      r3,[r0,#0x2c]
;;;297    }
000014  bd10              POP      {r4,pc}
;;;298    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;221     */
;;;222    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;223    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  f8dda038          LDR      r10,[sp,#0x38]
;;;224        uint8_t u8UartClkSrcSel;
;;;225        uint32_t u32ClkTbl[4] = {__HXT, 0, __HIRC, __HIRC};
000010  4b19              LDR      r3,|L11.120|
000012  cb0f              LDM      r3,{r0-r3}
000014  e88d000f          STM      sp,{r0-r3}
;;;226        uint32_t u32Clk;
;;;227        uint32_t u32Baud_Div = 0;
000018  2700              MOVS     r7,#0
;;;228    
;;;229        u32ClkTbl[1] = CLK_GetPLLClockFreq();
00001a  f7fffffe          BL       CLK_GetPLLClockFreq
00001e  9001              STR      r0,[sp,#4]
;;;230    
;;;231        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000020  4816              LDR      r0,|L11.124|
000022  6800              LDR      r0,[r0,#0]
000024  f3c06b01          UBFX     r11,r0,#24,#2
;;;232    
;;;233        u32Clk = (u32ClkTbl[u8UartClkSrcSel]) / (((CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos) + 1);
000028  f85d102b          LDR      r1,[sp,r11,LSL #2]
00002c  f04f4080          MOV      r0,#0x40000000
000030  f8d00220          LDR      r0,[r0,#0x220]
000034  f3c02003          UBFX     r0,r0,#8,#4
000038  f1000001          ADD      r0,r0,#1
00003c  fbb1f9f0          UDIV     r9,r1,r0
;;;234    
;;;235        if(u32baudrate != 0) {
000040  b19c              CBZ      r4,|L11.106|
;;;236            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
000042  eb090054          ADD      r0,r9,r4,LSR #1
000046  fbb0f0f4          UDIV     r0,r0,r4
00004a  1e87              SUBS     r7,r0,#2
;;;237    
;;;238            if(u32Baud_Div > 0xFFFF)
00004c  f5b73f80          CMP      r7,#0x10000
000050  d308              BCC      |L11.100|
;;;239                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
000052  eb0900c4          ADD      r0,r9,r4,LSL #3
000056  fbb0f0f4          UDIV     r0,r0,r4
00005a  2102              MOVS     r1,#2
00005c  ebc11010          RSB      r0,r1,r0,LSR #4
000060  6268              STR      r0,[r5,#0x24]
000062  e002              B        |L11.106|
                  |L11.100|
;;;240            else
;;;241                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000064  f0475040          ORR      r0,r7,#0x30000000
000068  6268              STR      r0,[r5,#0x24]
                  |L11.106|
;;;242        }
;;;243    
;;;244        uart->LINE = u32data_width | u32parity | u32stop_bits;
00006a  ea460008          ORR      r0,r6,r8
00006e  ea40000a          ORR      r0,r0,r10
000072  60e8              STR      r0,[r5,#0xc]
;;;245    }
000074  e8bd9fff          POP      {r0-r12,pc}
;;;246    
                          ENDP

                  |L11.120|
                          DCD      ||.constdata||+0x10
                  |L11.124|
                          DCD      0x40000214

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;255     */
;;;256    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;257    {
;;;258        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk)| (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;259        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6842              LDR      r2,[r0,#4]
00000c  f4426200          ORR      r2,r2,#0x800
000010  6042              STR      r2,[r0,#4]
;;;260    }
000012  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;308     */
;;;309    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b510              PUSH     {r4,lr}
;;;310    {
000002  4603              MOV      r3,r0
;;;311        uint32_t  u32Count;
;;;312    
;;;313        for(u32Count=0; u32Count != u32WriteBytes; u32Count++) {
000004  2000              MOVS     r0,#0
000006  e007              B        |L13.24|
                  |L13.8|
;;;314            if(uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk) { /* Wait Tx empty and Time-out manner */
000008  699c              LDR      r4,[r3,#0x18]
00000a  f4140f00          TST      r4,#0x800000
00000e  d000              BEQ      |L13.18|
                  |L13.16|
;;;315                return u32Count;
;;;316            }
;;;317            uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;318        }
;;;319    
;;;320        return u32Count;
;;;321    }
000010  bd10              POP      {r4,pc}
                  |L13.18|
000012  5c0c              LDRB     r4,[r1,r0]            ;317
000014  601c              STR      r4,[r3,#0]            ;317
000016  1c40              ADDS     r0,r0,#1              ;313
                  |L13.24|
000018  4290              CMP      r0,r2                 ;313
00001a  d1f5              BNE      |L13.8|
00001c  bf00              NOP                            ;320
00001e  e7f7              B        |L13.16|
;;;322    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x01518000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x01518000

                          AREA ||.data||, DATA, ALIGN=2

                  u32EscapeFrame
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 128
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
